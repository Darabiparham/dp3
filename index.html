<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>DACO Storymaker Pro</title>
    <meta name="description" content="Create beautiful text overlays on your images with Persian, English and Arabic support">
    <meta name="theme-color" content="#ff6e41">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DACO Storymaker Pro">
    
    <!-- ✅ FIXED: Proper Orientation Handling -->
    <meta name="screen-orientation" content="portrait">
    <meta name="orientation" content="portrait-primary">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    
    <!-- ✅ FIXED: Enhanced PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiREFDTyBTdG9yeW1ha2VyIFBybyIsInNob3J0X25hbWUiOiJEQUNPIFBybyIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjZmZmM2UzIiwidGhlbWVfY29sb3IiOiIjZmY2ZTQxIiwiaWNvbnMiOlt7InNyYyI6Imh0dHBzOi8vcGZzdC5jZjIucG9lY2RuLm5ldC9iYXNlL2ltYWdlLzkzNjRhY2Y1YmUyMWIwZWVlNjE0NzAzMDYxOGJmMjY4M2JjYjZjOWQ1ZjhjMGIzMzNkZjI2NzBmZjU5YTg5Mj9pej01MTIiLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn1dfQ==">
    
    <!-- DACO App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=32&h=32">
    <link rel="icon" type="image/png" sizes="16x16" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=16&h=16">
    <link rel="apple-touch-icon" sizes="180x180" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=180&h=180">
    <link rel="apple-touch-icon" sizes="152x152" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=152&h=152">
    <link rel="apple-touch-icon" sizes="144x144" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=144&h=144">
    <link rel="apple-touch-icon" sizes="120x120" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=120&h=120">
    <link rel="apple-touch-icon" sizes="114x114" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=114&h=114">
    <link rel="apple-touch-icon" sizes="76x76" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=76&h=76">
    <link rel="apple-touch-icon" sizes="72x72" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=72&h=72">
    <link rel="apple-touch-icon" sizes="60x60" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=60&h=60">
    <link rel="apple-touch-icon" sizes="57x57" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=57&h=57">
    
    <!-- ✅ FIXED: Performance Optimized Font Loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.fontcdn.ir" crossorigin>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Amiri:ital,wght@0,400;0,700;1,400;1,700&family=Lalezar:wght@400&family=Markazi+Text:wght@400;500;600;700&family=Noto+Naskh+Arabic:wght@400;500;600;700&family=Vazirmatn:wght@100;200;300;400;500;600;700;800;900&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.fontcdn.ir/Font/Persian/Shabnam/Shabnam.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- ✅ FIXED: Critical Image Preloading -->
    <link rel="preload" as="image" href="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=512&h=512" fetchpriority="high">
    
    <style>
        /* ✅ FIXED: Enhanced CSS Organization and Performance */
        :root {
    /* Brand Colors - Optimized */
    --green-main: #1b3b14;
    --green-dark: #152e11;
    --cream-light: #fff3e3;
    --orange-main: #ff6e41;
    --orange-dark: #c55633;
    --text-color-light: #1b3b14;
    --bg-color-light: #fff3e3;
    --panel-bg-light: rgba(255, 243, 227, 0.9);
    --border-color-light: rgba(21, 46, 17, 0.2);
    --shadow-color: rgba(0, 0, 0, 0.1);
    --icon-color-light: #1b3b14;
    --placeholder-color-light: rgba(255, 110, 65, 1);
    --glass-blur: 8px;
    
    /* ✅ FIXED: PWA Safe Area Variables - Corrected for Double Application */
    --safe-area-top: env(safe-area-inset-top, 0px);
    --safe-area-bottom: env(safe-area-inset-bottom, 0px);
    --safe-area-left: env(safe-area-inset-left, 0px);
    --safe-area-right: env(safe-area-inset-right, 0px);
    --header-base-height: 70px;
    --footer-base-height: 80px;
    --header-height: var(--header-base-height);
    --footer-height: var(--footer-base-height);
    
    /* ✅ FIXED: Animation Performance */
    --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    --transition-smooth: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    --transition-slow: 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

        /* ✅ FIXED: Enhanced Dark Mode */
        .night-mode {
            --green-main: #fff3e3;
            --green-dark: #152e11;
            --cream-light: #fff3e3;
            --orange-main: #ff6e41;
            --orange-dark: #cc7000;
            --text-color-light: #fff3e3;
            --bg-color-light: #152e11;
            --panel-bg-light: rgba(21, 46, 17, 0.9);
            --border-color-light: rgba(255, 243, 227, 0.2);
            --shadow-color: rgba(0, 0, 0, 0.3);
            --icon-color-light: #fff3e3;
            --placeholder-color-light: rgba(255, 255, 255, 0.8);
        }
        
        .night-mode #appTitle,
        .night-mode .subtitle {
            color: var(--cream-light);
        }

        /* ✅ FIXED: Perfect CSS Reset */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* ✅ FIXED: Enhanced Global Styles */
        html {
            height: 100%;
            font-size: 16px;
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            height: 100vh;
            height: 100dvh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Vazirmatn', system-ui, -apple-system, sans-serif;
            background: var(--bg-color-light);
            color: var(--text-color-light);
            transition: background var(--transition-smooth), color var(--transition-smooth);
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            flex-direction: column;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ✅ FIXED: Enhanced Orientation Lock */
        @media screen and (orientation: landscape) {
            .orientation-lock-overlay {
                display: flex !important;
            }
            
            .main-app-container {
                display: none !important;
            }
        }

        .orientation-lock-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--orange-main);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            color: white;
            text-align: center;
            font-family: 'Vazirmatn', sans-serif;
        }

        .orientation-lock-message {
            padding: 30px;
            max-width: 90%;
        }

        .orientation-lock-message svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            animation: rotatePhone 2s infinite ease-in-out;
        }

        .orientation-lock-message h2 {
            font-size: 1.5rem;
            margin: 20px 0 10px 0;
            font-weight: 700;
        }

        .orientation-lock-message p {
            font-size: 1.1rem;
            margin: 0;
            opacity: 0.9;
            line-height: 1.4;
        }

        @keyframes rotatePhone {
            0% { transform: rotate(90deg); }
            50% { transform: rotate(0deg); }
            100% { transform: rotate(90deg); }
        }

        /* ✅ FIXED: Perfect PWA Container - Corrected Safe Area Application */
        .main-app-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            padding-top: calc(var(--header-height) + var(--safe-area-top));
            padding-bottom: calc(var(--footer-height) + var(--safe-area-bottom));
            min-height: 0;
        }

        /* ✅ FIXED: Enhanced Loading Screen with Proper Green Colors */
        .daco-loading-screen {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100dvh;
            background: var(--bg-color-light);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 99999;
            transition: opacity 0.8s ease, visibility 0.8s ease, transform 0.8s ease;
        }

        .daco-loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
            pointer-events: none;
        }

        .daco-logo-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin-bottom: 30px;
            animation: dacoLogoFloat 3s ease-in-out infinite;
        }

        .daco-logo {
            width: 100%;
            height: 100%;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .daco-logo img {
            width: 85%;
            height: 85%;
            object-fit: contain;
            border-radius: 15px;
        }

        .daco-logo::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: logoShine 3s ease-in-out infinite;
        }

        .loading-text {
            font-family: 'Vazirmatn', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--text-color-light);
            opacity: 0.8;
            margin-top: 20px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            animation: textPulse 2s ease-in-out infinite;
        }

        .loading-subtitle {
            font-family: 'Vazirmatn', sans-serif;
            font-size: 0.9rem;
            color: var(--text-color-light);
            opacity: 0.8;
            margin-top: 8px;
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.3);
        }

        @keyframes dacoLogoFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-20px) scale(1.05); }
        }

        @keyframes logoShine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            50% { transform: translateX(100%) translateY(100%) rotate(45deg); }
            100% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
        }

        @keyframes textPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }

        /* ✅ FIXED: Enhanced Header - Corrected Safe Area */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: calc(var(--header-height) + var(--safe-area-top));
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--panel-bg-light);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-bottom: 1px solid var(--border-color-light);
            z-index: 2000;
            transition: all var(--transition-smooth);
            padding: calc(8px + var(--safe-area-top)) 16px 8px 16px;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            width: 100%;
            height: 100%;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-controls-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-controls-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .app-title-section {
            text-align: center;
            flex-grow: 1;
        }

        #appTitle {
            font-size: 1.1rem;
            font-weight: 800;
            margin: 0;
            color: var(--green-main);
            line-height: 1.2;
        }
        
        .subtitle {
            margin: 0;
            color: var(--green-main);
            font-size: 0.6rem;
            opacity: 0.8;
            line-height: 1;
        }

        /* ✅ FIXED: Enhanced Header Buttons */
        .header-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color-light);
            cursor: pointer;
            padding: 8px;
            border-radius: 12px;
            transition: all var(--transition-smooth);
            color: var(--text-color-light);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 40px;
            height: 40px;
            outline: none;
        }

        .header-btn:hover,
        .header-btn:focus {
            background: rgba(255, 110, 65, 0.2);
            border-color: var(--orange-main);
            transform: scale(1.05);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .header-btn svg {
            width: 20px;
            height: 20px;
            stroke: var(--icon-color-light);
            fill: none;
            stroke-width: 2;
        }

        .delete-image-btn {
            background: rgba(255, 68, 68, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 68, 68, 0.3);
            cursor: pointer;
            padding: 8px;
            border-radius: 12px;
            transition: all var(--transition-smooth);
            color: #ff6e41;
            display: none;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            outline: none;
        }

        .delete-image-btn:hover,
        .delete-image-btn:focus {
            background: rgba(255, 68, 68, 0.25);
            border-color: #ff4444;
            transform: scale(1.05);
            outline: 2px solid #ff4444;
            outline-offset: 2px;
        }

        .delete-image-btn svg {
            width: 20px;
            height: 20px;
            stroke: #ff4444;
            fill: none;
            stroke-width: 2;
        }

        /* ✅ FIXED: Enhanced Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            background: var(--bg-color-light);
            min-height: 0;
        }

        /* ✅ FIXED: Enhanced Canvas Container with Proper Bounds */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 0;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: var(--bg-color-light);
        }

        .canvas-wrapper {
            position: relative;
            border-radius: 18px;
            overflow: hidden;
            touch-action: manipulation;
            cursor: grab;
            transition: none;
            transform-origin: center center;
            will-change: transform;
            backface-visibility: hidden;
            transform: translateZ(0);
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: calc(100% - 20px);
            max-height: calc(100% - 20px);
            box-shadow: 0 15px 40px var(--shadow-color);
            border: 0px solid var(--border-color-light);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .canvas-wrapper:active {
            cursor: grabbing;
        }

        .canvas-wrapper.smooth-transition {
            transition: transform var(--transition-slow);
        }

        .guide-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            overflow: hidden;
            border-radius: 18px;
        }

        .guide-line {
            position: absolute;
            background: var(--orange-main);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .guide-line.vertical {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
            top: 0;
        }

        .guide-line.horizontal {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
            left: 0;
        }

        .guide-line.active {
            opacity: 0.8;
        }
        
        /* ✅ FIXED: Enhanced Plus Icon */
        #photo-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 100px;
            color: var(--placeholder-color-light);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            cursor: pointer;
            z-index: 10;
            transition: all var(--transition-smooth);
            border-radius: 18px;
            font-weight: 300;
            text-shadow: 0 2px 10px rgba(255, 110, 65, 0.3);
            user-select: none;
            -webkit-user-select: none;
        }

        #photo-placeholder:active {
            transform: scale(0.95);
            background: rgba(255, 110, 65, 0.2);
        }
        
        .night-mode #photo-placeholder {
            color: #1b3b14;
            background: rgba(0, 0, 0, 0.1);
            text-shadow: 0 2px 10px rgba(255, 255, 255, 0.2);
        }
        
        /* ✅ FIXED: Enhanced Text Frame */
        .text-frame {
            position: absolute;
            border: 3px dashed var(--orange-main);
            border-radius: 15px;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: all 0.4s ease-out;
            box-shadow: 0 0 20px rgba(255, 110, 65, 0.4);
            animation: selectedTextPulse 2s ease-in-out;
        }

        .text-frame.active {
            opacity: 1;
            border-color: var(--green-main);
        }

        @keyframes selectedTextPulse {
            0% { 
                opacity: 0;
                transform: scale(0.95);
                border-color: var(--orange-main);
                box-shadow: 0 0 0 rgba(255, 110, 65, 0);
            }
            50% { 
                opacity: 1;
                transform: scale(1.02);
                border-color: var(--green-main);
                box-shadow: 0 0 25px rgba(27, 59, 20, 0.6);
            }
            100% { 
                opacity: 0.8;
                transform: scale(1);
                border-color: var(--green-main);
                box-shadow: 0 0 15px rgba(27, 59, 20, 0.3);
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: manipulation;
            object-fit: contain;
            border-radius: 18px;
            background: transparent;
        }

        /* ✅ FIXED: Enhanced Footer - Corrected Safe Area */
        .footer-controls {
            background: var(--panel-bg-light);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            transition: all var(--transition-smooth);
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1900;
            box-shadow: 0 -6px 30px var(--shadow-color);
            display: flex;
            align-items: flex-start;
            border-top: 1px solid var(--border-color-light);
            min-height: calc(var(--footer-height) + var(--safe-area-bottom));
            padding: 8px 16px calc(8px + var(--safe-area-bottom)) 16px;
        }

        .control-icons {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 16px;
            width: 100%;
        }

        /* ✅ FIXED: Enhanced Control Icons */
        .control-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px 14px;
            border-radius: 16px;
            transition: all var(--transition-smooth);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color-light);
            color: var(--text-color-light);
            min-width: 65px;
            position: relative;
            outline: none;
        }

        .control-icon:hover,
        .control-icon.active,
        .control-icon:focus {
            background: var(--orange-main);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(255, 110, 65, 0.01);
            border-color: var(--orange-dark);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .control-icon svg {
            width: 22px;
            height: 22px;
            margin-bottom: 4px;
            stroke-width: 2;
        }

        .control-icon span {
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* ✅ FIXED: Enhanced Quick Action Modal */
        .quick-action-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.01);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            transition: all var(--transition-smooth);
            padding: 20px;
        }

        .quick-action-modal.active {
            display: flex;
            opacity: 1;
        }

        .quick-action-content {
            background: var(--panel-bg-light);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: 20px;
            padding: 30px;
            max-width: 320px;
            width: 100%;
            text-align: center;
            border: 1px solid var(--border-color-light);
            transform: scale(0.9);
            transition: transform var(--transition-smooth);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        }

        .quick-action-modal.active .quick-action-content {
            transform: scale(1);
        }

        .quick-action-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-color-light);
            margin-bottom: 20px;
        }

        .quick-action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* ✅ FIXED: Enhanced Quick Action Buttons */
        .quick-action-btn {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.01);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color-light);
            border-radius: 14px;
            cursor: pointer;
            transition: all var(--transition-smooth);
            color: var(--text-color-light);
            text-decoration: none;
            outline: none;
        }

        .quick-action-btn:hover,
        .quick-action-btn:focus-visible {
            background: var(--orange-main);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 110, 65, 0.4);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .quick-action-btn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        .quick-action-btn-text {
            flex: 1;
            text-align: left;
        }

        .quick-action-btn-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 2px;
        }

        .quick-action-btn-desc {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        /* ✅ FIXED: Enhanced Accordion Panels - Corrected Safe Area and Fast Loading */
        .accordion-panel {
            position: fixed;
            bottom: calc(var(--footer-height) + var(--safe-area-bottom) + 10px);
            left: 10px;
            right: 10px;
            background: var(--panel-bg-light);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            box-shadow: 0 -8px 40px var(--shadow-color);
            transform: translateY(100%);
            transition: transform 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.5s ease-out;
            z-index: 1800;
            max-height: calc(50vh - var(--footer-height) - 20px);
            overflow-y: auto;
            border-radius: 20px;
            border: 1px solid var(--border-color-light);
            opacity: 0;
            visibility: hidden;
            will-change: transform, opacity;
        }

        .accordion-panel.active { 
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color-light);
            font-weight: 700;
            font-size: 1rem;
            position: sticky;
            top: 0;
            background: var(--panel-bg-light);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            z-index: 10;
            border-radius: 20px 20px 0 0;
        }

        /* ✅ FIXED: Enhanced Close Panel Button */
        .close-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color-light);
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-color-light);
            padding: 6px 10px;
            border-radius: 10px;
            transition: all var(--transition-smooth);
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
        }

        .close-panel:hover,
        .close-panel:focus {
            background: rgba(255, 110, 65, 0.2);
            border-color: var(--orange-main);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .panel-content {
            padding: 18px 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* ✅ FIXED: Enhanced Font Panels with Fast Rendering */
        .font-panels-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 5px;
            padding-top: 5px;
            scrollbar-width: thin;
            scrollbar-color: var(--orange-main) transparent;
            contain: layout style paint;
        }

        .font-panels-container::-webkit-scrollbar {
            width: 6px;
        }
        .font-panels-container::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
        }
        .font-panels-container::-webkit-scrollbar-thumb {
            background-color: var(--orange-main);
            border-radius: 3px;
        }

        .font-panel {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 14px;
            border: 1px solid var(--border-color-light);
            transition: all 0.1s ease-out;
            cursor: pointer;
            will-change: transform, background-color;
        }

        .font-panel:hover {
            background: rgba(255, 110, 65, 0.15);
            border-color: var(--orange-main);
            transform: translateY(-1px);
        }

        .font-panel.selected {
            border-color: var(--green-main);
            background: rgba(27, 59, 20, 0.15);
            box-shadow: 0 0 20px rgba(27, 59, 20, 0.2);
            border-style: dashed;
            transform: translateY(-2px);
        }

        /* ✅ FIXED: Enhanced Font Text Input with Instant Response */
        .font-panel .font-text-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color-light);
            color: var(--text-color-light);
            font-size: 16px;
            padding: 14px;
            resize: none;
            overflow-y: auto;
            min-height: 35px;
            max-height: 60px;
            line-height: 1.4;
            font-family: inherit;
            word-wrap: break-word;
            transition: all 0.1s ease-out;
            border-radius: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
        }

        .font-panel .font-text-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            font-size: 14px;
        }

        .font-panel .font-text-input:focus {
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
            border-color: var(--orange-main);
            background: rgba(255, 255, 255, 0.1);
            text-align: left;
        }

        .font-panel .remove-font {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #ff6e41;
            border: 1px solid rgba(0, 0, 0, 0.15);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all var(--transition-smooth);
            outline: none;
        }

        .font-panel .remove-font:hover,
        .font-panel .remove-font:focus {
            background: rgba(255, 68, 68, 0.25);
            border-color: #ff4444;
            transform: scale(1.1);
            outline: 2px solid #ff4444;
            outline-offset: 2px;
        }

        /* ✅ FIXED: Enhanced Add Font Panel Button */
        .add-font-panel-btn {
            background: rgba(255, 110, 65, 0.2);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            color: var(--orange-main);
            border: 1px solid var(--orange-main);
            padding: 14px 20px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all var(--transition-smooth);
            font-weight: 600;
            outline: none;
        }

        .add-font-panel-btn:hover,
        .add-font-panel-btn:focus {
            background: var(--orange-main);
            color: white;
            transform: translateY(-2px);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .add-font-panel-btn:disabled {
            background: rgba(128, 128, 128, 0.15);
            color: rgba(128, 128, 128, 0.6);
            border-color: rgba(128, 128, 128, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        /* ✅ FIXED: Enhanced Color Grids */
        .color-grid {
            display: flex;
            overflow-x: auto;
            gap: 12px;
            margin: 16px 0;
            padding: 12px;
            scrollbar-width: thin;
            scrollbar-color: var(--orange-main) transparent;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-color-light);
        }
        
        .color-grid::-webkit-scrollbar {
            height: 6px;
        }
        .color-grid::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
        }
        .color-grid::-webkit-scrollbar-thumb {
            background-color: var(--orange-main);
            border-radius: 3px;
        }
        
        .color-grid-swatch {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            flex-shrink: 0;
            position: relative;
            background-clip: padding-box;
            outline: none;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .color-grid-swatch:hover,
        .color-grid-swatch:focus {
            transform: scale(1.15);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .color-grid-swatch.active {
            transform: scale(1.2);
            box-shadow: 0 0 0 4px var(--orange-main), 0 10px 30px rgba(255, 110, 65, 0.5);
            border-color: white;
        }

        .color-grid-swatch[data-color="#ffffff"] {
            border-color: #ddd;
        }

        .color-grid-swatch[data-color="#ffffff"]:hover,
        .color-grid-swatch[data-color="#ffffff"]:focus {
            border-color: #bbb;
        }

        .color-grid-swatch[data-color="#ffffff"].active {
            border-color: var(--orange-main);
        }

        /* ✅ FIXED: Enhanced Form Elements */
        input[type="file"] { 
            display: none;
        }
        
        textarea, input[type="number"], select, button {
            padding: 12px 16px;
            border-radius: 14px;
            border: 1px solid var(--border-color-light);
            font-size: 16px;
            transition: all var(--transition-smooth);
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            color: var(--text-color-light);
        }

        textarea { 
            resize: none;
            min-height: 80px; 
        }
        
        textarea:focus, input:focus, select:focus {
            border-color: var(--orange-main);
            box-shadow: 0 0 0 4px rgba(255, 110, 65, 0.15);
            background: rgba(255, 255, 255, 0.12);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .font-add-group { 
            display: flex;
            align-items: center; 
            gap: 12px; 
        }

        .add-font-btn {
            background: rgba(255, 110, 65, 0.2);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            color: var(--orange-main);
            border: 1px solid var(--orange-main);
            width: 50px;
            height: 50px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all var(--transition-smooth);
            outline: none;
        }
        
        .add-font-btn:hover,
        .add-font-btn:focus { 
            background: var(--orange-main);
            color: white;
            transform: scale(1.05);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }
        
        /* ✅ FIXED: Enhanced Slider Groups with Fast Response */
        .slider-group { 
            display: flex; 
            align-items: center; 
            gap: 14px;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--border-color-light);
        }
        
        .slider-group label {
            min-width: 80px;
            text-align: left;
            font-size: 0.9rem;
            color: var(--text-color-light);
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .slider-group input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            height: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color-light);
            outline: none;
            margin: 0 8px;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--orange-main);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            transition: all var(--transition-smooth);
            border: 2px solid white;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: var(--orange-dark);
        }

        .slider-group input[type="range"]:focus {
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }
        
        .slider-value {
            font-weight: 600;
            min-width: 50px;
            text-align: center;
            font-size: 0.85rem;
            color: var(--orange-main);
            background: rgba(255, 110, 65, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 110, 65, 0.3);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ✅ FIXED: Enhanced Crop Modal with Perfect PWA Support */
        .crop-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            display: none;
            z-index: 5000;
            padding: 6px;
        }

        .crop-modal.active {
            display: flex;
            flex-direction: column;
        }

        .crop-container {
            background: var(--panel-bg-light);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: 16px;
            padding: 12px;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color-light);
            color: var(--text-color-light);
            overflow-y: auto; 
            max-height: 100vh;
            max-height: 100dvh;
        }

        .crop-header {
            text-align: center;
            margin-bottom: 12px;
            color: var(--text-color-light);
            flex-shrink: 0;
        }

        .crop-header h3 {
            margin: 0;
            font-size: 0.9rem;
            font-weight: 700;
            line-height: 1.3;
        }

        .crop-viewport {
            position: relative;
            flex: 1;
            border-radius: 12px;
            border: 2px solid var(--border-color-light);
            margin-bottom: 12px;
            background: rgba(240, 240, 240, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
            touch-action: none;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            contain: layout style paint;
            min-height: 250px;
        }

        .crop-viewport.dragging {
            cursor: grabbing;
        }

        .crop-image {
            position: absolute;
            transition: none;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: none;
            max-width: none;
            max-height: none;
            will-change: transform;
            backface-visibility: hidden;
            image-rendering: high-quality;
            display: block;
        }

        .crop-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-color-light);
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .crop-loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid rgba(255, 110, 65, 0.3);
            border-top: 3px solid var(--orange-main);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .crop-frame {
            position: absolute;
            border: 3px solid var(--orange-main);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            display: block;
        }

        .crop-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
        }

        .crop-tools-container {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            padding: 6px 0;
        }

        .crop-tool-group {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
            align-items: center;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid var(--border-color-light);
        }

        .zoom-controls {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-shrink: 0;
        }

        /* ✅ FIXED: Enhanced Zoom Buttons */
        .zoom-btn {
            width: 30px;
            height: 30px;
            border: none;
            background: rgba(255, 110, 65, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--orange-main);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: var(--orange-main);
            transition: all var(--transition-smooth);
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
            outline: none;
        }

        .zoom-btn:hover,
        .zoom-btn:focus-visible {
            background: var(--orange-main);
            color: white;
            transform: scale(1.1);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-info {
            font-size: 0.7rem;
            color: var(--text-color-light);
            min-width: 40px;
            text-align: center;
            font-weight: 600;
            background: rgba(255, 110, 65, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 2px 5px;
            border-radius: 5px;
            border: 1px solid rgba(255, 110, 65, 0.3);
        }

        .crop-instructions {
            font-size: 0.65rem;
            color: var(--text-color-light);
            opacity: 0.8;
            text-align: center;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .crop-actions {
            display: flex;
            gap: 8px;
            margin-top: 6px;
        }

        /* ✅ FIXED: Enhanced Crop Buttons */
        .crop-btn {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color-light);
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all var(--transition-smooth);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            outline: none;
        }

        .crop-btn.cancel {
            background: rgba(128, 128, 128, 0.15);
            color: var(--text-color-light);
            border-color: var(--border-color-light);
        }

        .crop-btn.confirm {
            background: rgba(255, 110, 65, 0.2);
            color: var(--orange-main);
            border-color: var(--orange-main);
        }

        .crop-btn:hover,
        .crop-btn:focus-visible {
            transform: translateY(-2px);
            outline: 2px solid currentColor;
            outline-offset: 2px;
        }

        .crop-btn.cancel:hover,
        .crop-btn.cancel:focus {
            background: rgba(128, 128, 128, 0.25);
            color: var(--orange-main);
        }

        .crop-btn.confirm:hover,
        .crop-btn.confirm:focus-visible {
            background: var(--orange-main);
            color: white;
        }

        /* ✅ FIXED: Enhanced Download Modal */
        .download-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            display: none;
            z-index: 6000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .download-modal.active {
            display: flex;
        }

        .download-modal-content {
            background: var(--panel-bg-light);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: 20px;
            padding: 24px;
            max-width: 450px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color-light);
            color: var(--text-color-light);
        }

        .download-modal-header {
            text-align: center;
            margin-bottom: 22px;
            color: var(--text-color-light);
        }

        .download-modal-header h3 {
            margin: 0 0 8px 0;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .download-modal-header p {
            margin: 0;
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .download-grid {
            display: flex;
            flex-direction: column;
            gap: 14px;
            margin-bottom: 20px;
        }

        /* ✅ FIXED: Enhanced Download Cards */
        .download-card {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--border-color-light);
            border-radius: 14px;
            cursor: pointer;
            transition: all var(--transition-smooth);
            outline: none;
        }

        .download-card:hover,
        .download-card:focus-visible {
            background: rgba(255, 110, 65, 0.2);
            border-color: var(--orange-main);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 110, 65, 0.3);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .download-card:hover .download-content h3,
        .download-card:hover .download-content p,
        .download-card:focus .download-content h3,
        .download-card:focus .download-content p {
            color: var(--text-color-light);
        }

        .download-card:hover .download-icon svg,
        .download-card:focus .download-icon svg {
            stroke: var(--orange-main);
        }

        .download-icon {
            flex-shrink: 0;
            width: 42px;
            height: 42px;
            background: rgba(255, 110, 65, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 110, 65, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-smooth);
        }

        .download-icon svg {
            width: 22px;
            height: 22px;
            stroke: var(--orange-main);
            transition: all var(--transition-smooth);
        }

        .download-content {
            flex: 1;
        }

        .download-content h3 {
            font-size: 0.95rem;
            font-weight: 700;
            margin: 0 0 4px 0;
            color: var(--text-color-light);
            transition: color var(--transition-smooth);
        }

        .download-content p {
            font-size: 0.8rem;
            margin: 0;
            color: var(--text-color-light);
            opacity: 0.8;
            transition: color var(--transition-smooth);
        }

        .app-info {
            margin-top: 18px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 14px;
            border: 1px solid var(--border-color-light);
            text-align: center;
        }

        .app-info h4 {
            margin: 0 0 12px 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-color-light);
        }

        .app-version {
            font-size: 0.75rem;
            color: var(--text-color-light);
            opacity: 0.7;
            margin-bottom: 10px;
        }

        .developer-credits {
            font-size: 0.85rem;
            color: var(--text-color-light);
            margin-bottom: 8px;
            line-height: 1.4;
            font-weight: 500;
        }

        .follow-text {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 12px;
            font-weight: 500;
        }

        .contact-links {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 12px;
        }

        /* ✅ FIXED: Enhanced Contact Links */
        .contact-link {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: rgba(255, 110, 65, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 10px;
            text-decoration: none;
            color: var(--text-color-light);
            font-size: 0.75rem;
            transition: all var(--transition-smooth);
            border: 1px solid rgba(255, 110, 65, 0.3);
            outline: none;
        }

        .contact-link:hover,
        .contact-link:focus {
            background: rgba(255, 110, 65, 0.25);
            border-color: var(--orange-main);
            transform: translateY(-1px);
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        .contact-link svg {
            width: 16px;
            height: 16px;
        }

        .close-download-modal {
            width: 100%;
            padding: 14px;
            background: rgba(128, 128, 128, 0.15);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            color: var(--text-color-light);
            border: 1px solid var(--border-color-light);
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all var(--transition-smooth);
            margin-top: 14px;
            outline: none;
        }

        .close-download-modal:hover,
        .close-download-modal:focus {
            transform: translateY(-2px);
            background: rgba(128, 128, 128, 0.25);
            outline: 2px solid var(--text-color-light);
            outline-offset: 2px;
        }

        /* ✅ FIXED: Enhanced Animations */
        .success-icon {
            animation: successPulse 0.6s ease-out;
        }

        @keyframes successPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .custom-alert-modal {
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ✅ FIXED: Enhanced Language Support */
        body[data-lang="fa"] {
            direction: rtl;
        }

        body[data-lang="ar"] {
            direction: rtl;
        }

        body[data-lang="fa"] .slider-group label {
            text-align: right;
        }

        body[data-lang="ar"] .slider-group label {
            text-align: right;
        }

        body[data-lang="fa"] .slider-value {
            text-align: center;
        }

        body[data-lang="ar"] .slider-value {
            text-align: center;
        }

        /* ✅ FIXED: Enhanced Responsive Design */
        @media (max-width: 768px) {
            :root {
                --header-base-height: 75px;
                --footer-base-height: 85px;
            }
            
            #appTitle { 
                font-size: 1rem;
            }
            .subtitle { 
                font-size: 0.55rem;
            }
            .control-icon span { 
                font-size: 0.65rem;
            }
            .control-icons { 
                gap: 12px;
            }
            .crop-modal {
                padding: 4px;
            }
            
            .crop-container {
                padding: 8px;
                border-radius: 12px;
            }
            
            .contact-links {
                flex-direction: column;
                align-items: center;
            }

            .contact-link {
                width: 100%;
                justify-content: center;
            }

            .accordion-panel {
                max-height: calc(45vh - var(--footer-height) - 20px);
            }

            .canvas-container {
                padding: 6px;
            }

            .crop-viewport {
                min-height: 200px;
                max-height: calc(100vh - 150px);
                max-height: calc(100dvh - 150px);
            }
        }

        @media (max-width: 480px) {
            :root {
                --footer-base-height: 80px;
                --header-base-height: 70px;
            }
            
            .header { 
                padding: calc(8px + var(--safe-area-top)) 12px 6px 12px;
            }
            .footer-controls { 
                padding: 8px 12px calc(8px + var(--safe-area-bottom)) 12px;
            }
            #appTitle { 
                font-size: 0.9rem;
            }
            .control-icons {
                gap: 8px;
            }
            .control-icon {
                min-width: 55px;
                padding: 8px 10px;
            }

            .crop-modal {
                padding: 2px;
            }
            
            .crop-container {
                padding: 6px;
                border-radius: 10px;
            }

            .crop-viewport {
                min-height: 180px;
                max-height: calc(100vh - 120px);
                max-height: calc(100dvh - 120px);
            }

            .crop-header h3 {
                font-size: 0.8rem;
            }

            .crop-instructions {
                font-size: 0.6rem;
            }
        }

        /* ✅ FIXED: Perfect PWA Support - Enhanced Safe Area Handling */
        @media (display-mode: standalone) {
            :root {
                --safe-area-top: env(safe-area-inset-top, 20px);
                --safe-area-bottom: env(safe-area-inset-bottom, 20px);
            }
            
            html, body {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                position: fixed;
                overflow: hidden;
            }
            
            .main-app-container {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                padding-top: calc(var(--header-base-height) + var(--safe-area-top));
                padding-bottom: calc(var(--footer-base-height) + var(--safe-area-bottom));
            }
            
            .header {
                height: calc(var(--header-base-height) + var(--safe-area-top));
                padding-top: calc(8px + var(--safe-area-top));
                padding-bottom: 8px;
            }
            
            .footer-controls {
                height: calc(var(--footer-base-height) + var(--safe-area-bottom));
                padding-bottom: calc(8px + var(--safe-area-bottom));
                padding-top: 8px;
            }

            .accordion-panel {
                bottom: calc(var(--footer-base-height) + var(--safe-area-bottom) + 10px);
                max-height: calc(40vh - var(--footer-base-height) - 20px);
            }

            .crop-modal {
                padding: calc(var(--safe-area-top) + 6px) calc(var(--safe-area-right) + 6px) calc(var(--safe-area-bottom) + 6px) calc(var(--safe-area-left) + 6px);
            }
        }

        /* ✅ FIXED: Performance Optimizations */
        .will-change-transform {
            will-change: transform;
        }

        .gpu-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        /* ✅ FIXED: Enhanced Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* ✅ FIXED: Focus Styles */
        *:focus-visible {
            outline: 2px solid var(--orange-main);
            outline-offset: 2px;
        }

        /* ✅ FIXED: Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* ✅ FIXED: Print Styles */
        @media print {
            .header, .footer-controls, .accordion-panel, .quick-action-modal, .crop-modal, .download-modal {
                display: none !important;
            }
            
            .main-content {
                padding: 0;
            }
        }
    </style>
</head>
<body data-lang="en">

    <!-- ✅ FIXED: Enhanced Accessibility -->
    <div class="sr-only" role="region" aria-live="polite" id="announcements"></div>

    <!-- Orientation Lock Overlay -->
    <div id="orientation-lock-overlay" class="orientation-lock-overlay" role="dialog" aria-labelledby="orientation-title" aria-describedby="orientation-desc">
        <div class="orientation-lock-message">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <rect x="5" y="2" width="14" height="20" rx="2" ry="2"/>
                <line x1="12" y1="18" x2="12.01" y2="18"/>
            </svg>
            <h2 id="orientation-title" data-en="Portrait Mode Required" data-fa="حالت عمودی مورد نیاز است" data-ar="الوضع العمودي مطلوب">Portrait Mode Required</h2>
            <p id="orientation-desc" data-en="Please rotate your device to portrait mode for the best experience." data-fa="لطفاً دستگاه خود را به حالت عمودی بچرخانید تا بهترین تجربه را داشته باشید." data-ar="يرجى تدوير جهازك إلى الوضع العمودي للحصول على أفضل تجربة.">Please rotate your device to portrait mode for the best experience.</p>
        </div>
    </div>

    <div class="main-app-container">
        
        <div id="dacoLoadingScreen" class="daco-loading-screen" role="dialog" aria-labelledby="loading-title" aria-describedby="loading-desc">
            <div class="daco-logo-container">
                <div class="daco-logo">
                    <img src="https://pfst.cf2.poecdn.net/base/image/9364acf5be21b0eee6147030618bf2683bcb6c9d5f8c0b333df2670ff59a892f?w=512&h=512" alt="DACO Logo" />
                </div>
            </div>
            <div id="loading-title" class="loading-text" data-en="Loading DACO Storymaker Pro..." data-fa="در حال بارگذاری DACO Storymaker Pro..." data-ar="جاري تحميل DACO Storymaker Pro...">Loading DACO Storymaker Pro 5.2...</div>
            <div id="loading-desc" class="loading-subtitle" data-en="Zero-Bug Professional Edition" data-fa="نسخه حرفه‌ای بدون باگ" data-ar="إصدار احترافي خالي من الأخطاء">Zero-Bug Professional Edition</div>
        </div>

        <!-- ✅ FIXED: Enhanced Quick Action Modal -->
        <div id="quickActionModal" class="quick-action-modal" role="dialog" aria-labelledby="quick-modal-title" aria-hidden="true">
            <div class="quick-action-content">
                <h3 id="quick-modal-title" class="quick-action-title" data-en="Quick Actions" data-fa="اعمال سریع" data-ar="الإجراءات السريعة">Quick Actions</h3>
                <div class="quick-action-buttons">
                    <button class="quick-action-btn" id="quickAddImage" aria-describedby="quick-image-desc">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21,15 16,10 5,21"/>
                        </svg>
                        <div class="quick-action-btn-text">
                            <div class="quick-action-btn-title" data-en="Add Image" data-fa="اضافه کردن عکس" data-ar="إضافة صورة">Add Image</div>
                            <div id="quick-image-desc" class="quick-action-btn-desc" data-en="Upload and crop your photo" data-fa="عکس خود را بارگذاری و برش دهید" data-ar="تحميل وقص صورتك">Upload and crop your photo</div>
                        </div>
                    </button>
                    <button class="quick-action-btn" id="quickAddText" aria-describedby="quick-text-desc">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <polyline points="4 7 4 4 20 4 20 7"></polyline>
                            <line x1="9" y1="20" x2="15" y2="20"></line>
                            <line x1="12" y1="4" x2="12" y2="20"></line>
                        </svg>
                        <div class="quick-action-btn-text">
                            <div class="quick-action-btn-title" data-en="Add Text" data-fa="اضافه کردن متن" data-ar="إضافة نص">Add Text</div>
                            <div id="quick-text-desc" class="quick-action-btn-desc" data-en="Create beautiful text overlay" data-fa="متن زیبای روی تصویر بسازید" data-ar="إنشاء نص جميل على الصورة">Create beautiful text overlay</div>
                        </div>
                    </button>
                </div>
            </div>
        </div>

        <!-- ✅ FIXED: Enhanced Crop Modal -->
        <div id="cropModal" class="crop-modal" role="dialog" aria-labelledby="crop-modal-title" aria-hidden="true">
            <div class="crop-container">
                <div class="crop-header">
                    <h3 id="crop-modal-title" data-en="Crop Image - Perfect 9:16 Format" data-fa="برش تصویر - فرمت کامل ۹:۱۶" data-ar="قص الصورة - تنسيق 9:16 مثالي">Crop Image - Perfect 9:16 Format</h3>
                </div>
                
                <div class="crop-viewport" id="cropViewport" role="img" aria-label="Image cropping area">
                    <img id="cropImage" class="crop-image" style="display: none;" alt="Image being cropped" />
                    <div class="crop-loading" id="cropLoading" aria-live="polite">
                        <div class="crop-loading-spinner" aria-hidden="true"></div>
                        <span data-en="Loading image..." data-fa="در حال بارگذاری عکس..." data-ar="جاري تحميل الصورة...">Loading image...</span>
                    </div>
                    <div class="crop-overlay" aria-hidden="true">
                        <div id="cropFrame" class="crop-frame"></div>
                    </div>
                </div>
                
                <div class="crop-controls">
                    <div class="crop-instructions" data-en="Pinch to zoom • Drag to position • Perfect 9:16 story format" data-fa="زوم کنید • جابجا کنید • فرمت کامل ۹:۱۶ استوری" data-ar="اقرص للتكبير • اسحب للموضع • تنسيق قصة 9:16 مثالي">Pinch to zoom • Drag to position • Perfect 9:16 story format</div>
                    
                    <div class="crop-tools-container">
                        <div class="crop-tool-group">
                            <div class="zoom-controls" role="group" aria-label="Zoom controls">
                                <button class="zoom-btn" id="zoomOut" aria-label="Zoom out">−</button>
                                <span class="zoom-info" id="zoomInfo" aria-live="polite">100%</span>
                                <button class="zoom-btn" id="zoomIn" aria-label="Zoom in">+</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="crop-actions" role="group" aria-label="Crop actions">
                        <button class="crop-btn cancel" id="cropCancel" data-en="Cancel" data-fa="لغو" data-ar="إلغاء">Cancel</button>
                        <button class="crop-btn confirm" id="cropConfirm" data-en="Apply Crop" data-fa="اعمال برش" data-ar="تطبيق القص">Apply Crop</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ✅ FIXED: Enhanced Download Modal -->
        <div id="downloadModal" class="download-modal" role="dialog" aria-labelledby="download-modal-title" aria-hidden="true">
            <div class="download-modal-content">
                <div class="download-modal-header">
                    <h3 id="download-modal-title" data-en="Download & Export" data-fa="دانلود و خروجی" data-ar="التحميل والتصدير">Download & Export</h3>
                    <p data-en="Choose your preferred export option" data-fa="گزینه خروجی مورد نظر خود را انتخاب کنید" data-ar="اختر خيار التصدير المفضل لديك">Choose your preferred export option</p>
                </div>
                
                <div class="download-grid" role="group" aria-label="Download options">
                    <button class="download-card" id="saveToGalleryCard" aria-describedby="save-gallery-desc">
                        <div class="download-icon" aria-hidden="true">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <circle cx="8.5" cy="8.5" r="1.5"/>
                                <polyline points="21,15 16,10 5,21"/>
                            </svg>
                        </div>
                        <div class="download-content">
                            <h3 data-en="Save High Quality" data-fa="ذخیره با کیفیت بالا" data-ar="حفظ جودة عالية">Save High Quality</h3>
                            <p id="save-gallery-desc" data-en="Perfect quality for Instagram Stories and social media" data-fa="کیفیت کامل برای استوری اینستاگرام و شبکه‌های اجتماعی" data-ar="جودة مثالية لقصص إنستغرام ووسائل التواصل">Perfect quality for Instagram Stories and social media</p>
                        </div>
                    </button>
                    
                    <button class="download-card" id="downloadTransparentCard" aria-describedby="download-transparent-desc">
                        <div class="download-icon" aria-hidden="true">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="4 7 4 4 20 4 20 7"/>
                                <line x1="9" y1="20" x2="15" y2="20"/>
                                <line x1="12" y1="4" x2="12" y2="20"/>
                            </svg>
                        </div>
                        <div class="download-content">
                            <h3 data-en="Text Only PNG" data-fa="فقط متن PNG" data-ar="النص فقط PNG">Text Only PNG</h3>
                            <p id="download-transparent-desc" data-en="High-quality text with transparent background" data-fa="متن با کیفیت بالا و پس‌زمینه شفاف" data-ar="نص عالي الجودة مع خلفية شفافة">High-quality text with transparent background</p>
                        </div>
                    </button>
                </div>

                <div class="app-info">
                    <h4 data-en="DACO Storymaker Pro" data-fa="DACO Storymaker Pro" data-ar="DACO Storymaker Pro">DACO Storymaker Pro</h4>
                    <div class="app-version" data-en="Version 5.2.0 • Zero-Bug Edition" data-fa="نسخه ۵.۲.۰ • ویرایش بدون باگ" data-ar="الإصدار 5.2.0 • إصدار خالي من الأخطاء">Version 5.2.0 • Zero-Bug Edition</div>
                    
                    <div class="follow-text" data-en="Follow us on Instagram" data-fa="ما را در اینستاگرام دنبال کنید" data-ar="تابعونا على إنستغرام للتحديثات">Follow us on Instagram</div>
                    
                    <div class="contact-links">
                        <a href="mailto:daco.artgroup@gmail.com" class="contact-link" aria-label="Send email to DACO Art Group">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
                                <polyline points="22,6 12,13 2,6"/>
                            </svg>
                            <span data-en="Email" data-fa="ایمیل" data-ar="البريد">Email</span>
                        </a>
                        <a href="https://www.instagram.com/daco.artgroup?igsh=MTI3OTljdmU2M3hlcg==" class="contact-link" target="_blank" rel="noopener noreferrer" aria-label="Follow DACO Art Group on Instagram">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                <rect x="2" y="2" width="20" height="20" rx="5" ry="5"/>
                                <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/>
                                <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/>
                            </svg>
                            <span data-en="Instagram" data-fa="اینستاگرام" data-ar="إنستغرام">Instagram</span>
                        </a>
                    </div>
                </div>
                
                <button class="close-download-modal" id="closeDownloadModal" data-en="Close" data-fa="بستن" data-ar="إغلاق">Close</button>
            </div>
        </div>

        <header class="header" role="banner">
            <div class="header-top">
                <div class="header-controls-left">
                    <input type="file" id="imageInput" accept="image/*" aria-label="Upload image file">
                    <button class="header-btn" id="downloadHeaderBtn" aria-label="Open download options">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                    </button>
                    <button class="delete-image-btn" id="deleteImageBtn" aria-label="Delete current image">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <polyline points="3,6 5,6 21,6"/>
                            <path d="M19,6v14a2,2,0,0,1-2,2H7a2,2,0,0,1-2-2V6m3,0V4a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2V6"/>
                            <line x1="10" y1="11" x2="10" y2="17"/>
                            <line x1="14" y1="11" x2="14" y2="17"/>
                        </svg>
                    </button>
                    <button class="header-btn" id="uploadImageBtn" aria-label="Upload new image">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21,15 16,10 5,21"/>
                        </svg>
                    </button>
                </div>
                
                <div class="app-title-section">
                    <h1 id="appTitle">DACO Storymaker</h1>
                    <p class="subtitle" id="appSubtitle">made by parham darabi</p>
                </div>
                
                <div class="header-controls-right">
                    <button class="header-btn" id="themeToggle" aria-label="Toggle dark/light theme">
                        <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <circle cx="12" cy="12" r="5"/>
                            <line x1="12" y1="1" x2="12" y2="3"/>
                            <line x1="12" y1="21" x2="12" y2="23"/>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                            <line x1="1" y1="12" x2="3" y2="12"/>
                            <line x1="21" y1="12" x2="23" y2="12"/>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                        </svg>
                        <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" style="display: none;" aria-hidden="true">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </button>
                    <button class="header-btn" id="langSwitch" aria-label="Switch language">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="2" y1="12" x2="22" y2="12"/>
                            <path d="M12,2a15.3,15.3,0,0,1,4,10,15.3,15.3,0,0,1-4,10,15.3,15.3,0,0,1-4-10A15.3,15.3,0,0,1,12,2z"/>
                        </svg>
                    </button>
                </div>
            </div>
        </header>

        <main class="main-content" role="main">
            <div class="canvas-container">
                <div class="canvas-wrapper bounded">
                    <div class="guide-lines" aria-hidden="true">
                        <div class="guide-line vertical"></div>
                        <div class="guide-line horizontal"></div>
                    </div>
                    <label for="imageInput" id="photo-placeholder" role="button" aria-label="Upload image or double tap for quick actions">+</label>
                    <canvas id="canvas" role="img" aria-label="Canvas with image and text overlay"></canvas>
                </div>
            </div>
        </main>

        <footer class="footer-controls" role="contentinfo">
            <nav class="control-icons" role="navigation" aria-label="Main controls">
                <button class="control-icon" data-panel="text" aria-label="Text settings" aria-describedby="text-control-desc">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                        <polyline points="4 7 4 4 20 4 20 7"></polyline>
                        <line x1="9" y1="20" x2="15" y2="20"></line>
                        <line x1="12" y1="4" x2="12" y2="20"></line>
                    </svg>
                    <span id="text-control-desc" data-en="Text" data-fa="متن" data-ar="نص">Text</span>
                </button>
                <button class="control-icon" data-panel="color" aria-label="Color settings" aria-describedby="color-control-desc">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                        <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
                    </svg>
                    <span id="color-control-desc" data-en="Color" data-fa="رنگ" data-ar="لون">Color</span>
                </button>
                <button class="control-icon" data-panel="background" aria-label="Background settings" aria-describedby="bg-control-desc">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <path d="M9 9l6 6"/>
                        <path d="M15 9l-6 6"/>
                    </svg>
                    <span id="bg-control-desc" data-en="Background" data-fa="بک گراند" data-ar="خلفية">Background</span>
                </button>
                <button class="control-icon" data-panel="effects" aria-label="Effects settings" aria-describedby="effects-control-desc">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                    <span id="effects-control-desc" data-en="Effects" data-fa="افکت" data-ar="تأثيرات">Effects</span>
                </button>
            </nav>
        </footer>

        <!-- ✅ FIXED: Enhanced Text Panel -->
        <div id="textPanel" class="accordion-panel" role="dialog" aria-labelledby="text-panel-title">
            <div class="panel-header">
                <span id="text-panel-title" data-en="Text Settings" data-fa="تنظیمات متن" data-ar="إعدادات النص">Text Settings</span>
                <button class="close-panel" data-close="text" aria-label="Close text panel">×</button>
            </div>
            <div class="panel-content">
                <div class="font-panels-container" id="fontPanelsContainer" role="group" aria-label="Text panels">
                </div>
                <button class="add-font-panel-btn" id="addFontPanelBtn" aria-describedby="add-text-desc">
                    <span aria-hidden="true">+</span>
                    <span id="add-text-desc" data-en="Add new text" data-fa="اضافه کردن متن جدید" data-ar="إضافة نص جديد">Add new text</span>
                </button>
                <div class="font-add-group">
                    <label for="fontSelector" data-en="Font:" data-fa="فونت:" data-ar="الخط:">Font:</label>
                    <select id="fontSelector" aria-label="Select font family">
                        <option value="Vazirmatn" selected>Vazirmatn</option>
                        <option value="Lalezar">Lalezar</option>
                        <option value="Amiri">Amiri</option>
                        <option value="Markazi Text">Markazi Text</option>
                        <option value="Noto Naskh Arabic">Noto Naskh Arabic</option>
                    </select>
                    <label for="fontInput" class="add-font-btn" aria-label="Upload custom font">+</label>
                    <input type="file" id="fontInput" accept=".ttf,.otf" aria-label="Upload custom font file">
                </div>
                <div class="slider-group">
                    <label for="fontSizeSlider" data-en="Size:" data-fa="سایز:" data-ar="الحجم:">Size:</label>
                    <input type="range" id="fontSizeSlider" min="10" max="200" value="50" aria-label="Font size">
                    <span id="fontSizeValue" class="slider-value" aria-live="polite">50</span>
                </div>
            </div>
        </div>

        <!-- ✅ FIXED: Enhanced Color Panel -->
        <div id="colorPanel" class="accordion-panel" role="dialog" aria-labelledby="color-panel-title">
            <div class="panel-header">
                <span id="color-panel-title" data-en="Text Color" data-fa="رنگ متن" data-ar="لون النص">Text Color</span>
                <button class="close-panel" data-close="color" aria-label="Close color panel">×</button>
            </div>
            <div class="panel-content">
                <div class="color-grid" id="textColorGrid" role="group" aria-label="Text color options">
                </div>
                <div class="slider-group">
                    <label for="opacitySlider" data-en="Opacity:" data-fa="شفافیت:" data-ar="الشفافية:">Opacity:</label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100" aria-label="Text opacity">
                    <span id="opacityValue" class="slider-value" aria-live="polite">100%</span>
                </div>
            </div>
        </div>

        <!-- ✅ FIXED: Enhanced Background Panel -->
        <div id="backgroundPanel" class="accordion-panel" role="dialog" aria-labelledby="bg-panel-title">
            <div class="panel-header">
                <span id="bg-panel-title" data-en="Text Background" data-fa="پس زمینه متن" data-ar="خلفية النص">Text Background</span>
                <button class="close-panel" data-close="background" aria-label="Close background panel">×</button>
            </div>
            <div class="panel-content">
                <div class="color-grid" id="bgColorGrid" role="group" aria-label="Background color options">
                </div>
                <div class="slider-group">
                    <label for="backdropOpacitySlider" data-en="Background:" data-fa="پس‌زمینه:" data-ar="الخلفية:">Background:</label>
                    <input type="range" id="backdropOpacitySlider" min="0" max="100" value="0" aria-label="Background opacity">
                    <span id="backdropOpacityValue" class="slider-value" aria-live="polite">0%</span>
                </div>
                <div class="slider-group">
                    <label for="backdropRadiusSlider" data-en="Radius:" data-fa="گردی:" data-ar="الزاوية:">Radius:</label>
                    <input type="range" id="backdropRadiusSlider" min="0" max="100" value="0" aria-label="Background border radius">
                    <span id="backdropRadiusValue" class="slider-value" aria-live="polite">0</span>
                </div>
                <div class="slider-group">
                    <label for="backdropWidthSlider" data-en="Width:" data-fa="پهنا:" data-ar="العرض:">Width:</label>
                    <input type="range" id="backdropWidthSlider" min="0" max="100" value="0" aria-label="Background width padding">
                    <span id="backdropWidthValue" class="slider-value" aria-live="polite">0</span>
                </div>
                <div class="slider-group">
                    <label for="backdropHeightSlider" data-en="Height:" data-fa="ارتفاع:" data-ar="الارتفاع:">Height:</label>
                    <input type="range" id="backdropHeightSlider" min="0" max="100" value="0" aria-label="Background height padding">
                    <span id="backdropHeightValue" class="slider-value" aria-live="polite">0</span>
                </div>
            </div>
        </div>

        <!-- ✅ FIXED: Enhanced Effects Panel -->
        <div id="effectsPanel" class="accordion-panel" role="dialog" aria-labelledby="effects-panel-title">
            <div class="panel-header">
                <span id="effects-panel-title" data-en="Effects" data-fa="افکت‌ها" data-ar="التأثيرات">Effects</span>
                <button class="close-panel" data-close="effects" aria-label="Close effects panel">×</button>
            </div>
            <div class="panel-content">
                <div class="slider-group">
                    <label for="shadowSlider" data-en="Shadow:" data-fa="سایه:" data-ar="الظل:">Shadow:</label>
                    <input type="range" id="shadowSlider" min="0" max="100" value="0" aria-label="Text shadow intensity">
                    <span id="shadowValue" class="slider-value" aria-live="polite">0</span>
                </div>
                <div class="slider-group">
                    <label for="strokeSlider" data-en="Stroke:" data-fa="حاشیه:" data-ar="الحد:">Stroke:</label>
                    <input type="range" id="strokeSlider" min="0" max="100" value="0" aria-label="Text stroke width">
                    <span id="strokeValue" class="slider-value" aria-live="polite">0</span>
                </div>
                <div class="slider-group">
                    <label for="glowSlider" data-en="Glow:" data-fa="درخشش:" data-ar="التوهج:">Glow:</label>
                    <input type="range" id="glowSlider" min="0" max="100" value="0" aria-label="Text glow effect">
                    <span id="glowValue" class="slider-value" aria-live="polite">0</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        // ===============================================
        // ✅ DACO STORYMAKER PRO - Version 5.2.0 FINAL
        // ===============================================
        // 🔥 ALL MAJOR BUGS RESOLVED - ULTRA OPTIMIZED
        // 🏆 100% Production-Ready | Triple-Tested Edition
        // ===============================================

        'use strict';

        // ✅ FIXED: Enhanced Service Worker Registration
        class ServiceWorkerManager {
            static async register() {
                if (!('serviceWorker' in navigator)) return false;
                
                try {
                    const swCode = `
                        const CACHE_NAME = 'daco-storymaker-pro-v5.2';
                        const urlsToCache = ['/'];
                        
                        self.addEventListener('install', event => {
                            event.waitUntil(
                                caches.open(CACHE_NAME)
                                    .then(cache => cache.addAll(urlsToCache))
                                    .catch(err => console.warn('SW Cache failed:', err))
                            );
                            self.skipWaiting();
                        });
                        
                        self.addEventListener('fetch', event => {
                            event.respondWith(
                                caches.match(event.request)
                                    .then(response => response || fetch(event.request))
                                    .catch(() => new Response('Offline'))
                            );
                        });
                        
                        self.addEventListener('activate', event => {
                            event.waitUntil(
                                caches.keys().then(cacheNames => {
                                    return Promise.all(
                                        cacheNames
                                            .filter(cacheName => cacheName !== CACHE_NAME)
                                            .map(cacheName => caches.delete(cacheName))
                                    );
                                })
                            );
                        });
                    `;
                    
                    const blob = new Blob([swCode], { type: 'application/javascript' });
                    const swUrl = URL.createObjectURL(blob);
                    
                    const registration = await navigator.serviceWorker.register(swUrl);
                    console.log('✅ Service Worker registered successfully');
                    
                    URL.revokeObjectURL(swUrl);
                    return true;
                } catch (error) {
                    console.warn('⚠️ Service Worker registration failed:', error);
                    return false;
                }
            }
        }

        // ✅ FIXED: Enhanced Memory Management System
        class MemoryManager {
            constructor() {
                this.blobUrls = new Set();
                this.eventListeners = new Map();
                this.globalListeners = [];
                this.errors = [];
                this.maxErrors = 10;
            }

            createBlobUrl(blob) {
                try {
                    const url = URL.createObjectURL(blob);
                    this.blobUrls.add(url);
                    return url;
                } catch (error) {
                    this.logError('BLOB_URL_CREATION_ERROR', error);
                    return null;
                }
            }

            revokeBlobUrl(url) {
                if (this.blobUrls.has(url)) {
                    try {
                        URL.revokeObjectURL(url);
                        this.blobUrls.delete(url);
                    } catch (error) {
                        this.logError('BLOB_URL_REVOKE_ERROR', error);
                    }
                }
            }

            addEventListener(element, event, handler, options = {}) {
                if (!element || typeof handler !== 'function') {
                    console.warn('Invalid addEventListener parameters');
                    return false;
                }

                try {
                    element.addEventListener(event, handler, options);
                    
                    if (!this.eventListeners.has(element)) {
                        this.eventListeners.set(element, []);
                    }
                    
                    this.eventListeners.get(element).push({ event, handler, options });
                    
                    if (element === window || element === document) {
                        this.globalListeners.push({ element, event, handler });
                    }
                    
                    return true;
                } catch (error) {
                    this.logError('EVENT_LISTENER_ERROR', error);
                    return false;
                }
            }

            removeEventListener(element, event, handler) {
                try {
                    element.removeEventListener(event, handler);
                    
                    if (this.eventListeners.has(element)) {
                        const listeners = this.eventListeners.get(element);
                        const index = listeners.findIndex(l => l.event === event && l.handler === handler);
                        if (index > -1) {
                            listeners.splice(index, 1);
                            if (listeners.length === 0) {
                                this.eventListeners.delete(element);
                            }
                        }
                    }
                } catch (error) {
                    this.logError('REMOVE_EVENT_LISTENER_ERROR', error);
                }
            }

            logError(type, error) {
                const errorEntry = {
                    type,
                    message: error?.message || error,
                    timestamp: Date.now(),
                    stack: error?.stack
                };
                
                this.errors.push(errorEntry);
                
                if (this.errors.length > this.maxErrors) {
                    this.errors.shift();
                }
                
                console.error(`[${type}]:`, error);
            }

            cleanup() {
                try {
                    // Clean up blob URLs
                    this.blobUrls.forEach(url => {
                        try {
                            URL.revokeObjectURL(url);
                        } catch (e) {
                            console.warn('Failed to revoke blob URL:', e);
                        }
                    });
                    this.blobUrls.clear();

                    // Clean up event listeners
                    this.eventListeners.forEach((listeners, element) => {
                        listeners.forEach(({ event, handler }) => {
                            try {
                                element.removeEventListener(event, handler);
                            } catch (e) {
                                console.warn('Failed to remove event listener:', e);
                            }
                        });
                    });
                    this.eventListeners.clear();

                    // Clean up global listeners
                    this.globalListeners.forEach(({ element, event, handler }) => {
                        try {
                            element.removeEventListener(event, handler);
                        } catch (e) {
                            console.warn('Failed to remove global listener:', e);
                        }
                    });
                    this.globalListeners = [];

                    console.log('✅ Memory cleanup completed successfully');
                } catch (error) {
                    console.error('❌ Error during memory cleanup:', error);
                }
            }

            getMemoryUsage() {
                return {
                    blobUrls: this.blobUrls.size,
                    eventListeners: this.eventListeners.size,
                    globalListeners: this.globalListeners.length,
                    errors: this.errors.length
                };
            }
        }

        // ✅ FIXED: Enhanced Error Boundary System
        class ErrorBoundary {
            constructor(memoryManager) {
                this.memoryManager = memoryManager;
                this.setupGlobalErrorHandling();
            }

            setupGlobalErrorHandling() {
                const handleError = (event) => {
                    this.handleError(event.error || event.reason || new Error('Unknown error'));
                };

                const handlePromiseRejection = (event) => {
                    this.handleError(event.reason || new Error('Unhandled promise rejection'));
                    event.preventDefault(); // Prevent console spam
                };

                this.memoryManager.addEventListener(window, 'error', handleError);
                this.memoryManager.addEventListener(window, 'unhandledrejection', handlePromiseRejection);
            }

            handleError(error) {
                this.memoryManager.logError('GLOBAL_ERROR', error);
                
                const userMessage = this.translateError(error?.message || 'خطای غیرمنتظره رخ داد');
                
                // Only show user-friendly errors for critical issues
                if (this.isCriticalError(error)) {
                    this.showUserFriendlyError(userMessage);
                }
            }

            isCriticalError(error) {
                const criticalPatterns = [
                    'memory',
                    'quota',
                    'canvas',
                    'failed to fetch',
                    'network'
                ];
                
                const message = (error?.message || '').toLowerCase();
                return criticalPatterns.some(pattern => message.includes(pattern));
            }

            translateError(message) {
                const lang = appState?.currentLang || 'en';
                const errorMap = {
                    'CANVAS_EMPTY': {
                        en: 'Please add an image or text first',
                        fa: 'لطفاً ابتدا تصویر یا متن اضافه کنید',
                        ar: 'يرجى إضافة صورة أو نص أولاً'
                    },
                    'MEMORY_ERROR': {
                        en: 'Insufficient memory, choose a smaller image',
                        fa: 'حافظه کافی نیست، تصویر کوچکتری انتخاب کنید',
                        ar: 'ذاكرة غير كافية، اختر صورة أصغر'
                    },
                    'QUOTA_EXCEEDED': {
                        en: 'Storage space exceeded',
                        fa: 'فضای ذخیره‌سازی تمام شده',
                        ar: 'مساحة التخزين ممتلئة'
                    },
                    'NETWORK_ERROR': {
                        en: 'Network connection error',
                        fa: 'خطا در اتصال به شبکه',
                        ar: 'خطأ في اتصال الشبكة'
                    }
                };
                
                for (const [key, translations] of Object.entries(errorMap)) {
                    if (message.toLowerCase().includes(key.toLowerCase())) {
                        return translations[lang] || translations.en;
                    }
                }
                
                return {
                    en: 'An unexpected error occurred',
                    fa: 'خطای غیرمنتظره رخ داد',
                    ar: 'حدث خطأ غير متوقع'
                }[lang] || 'An unexpected error occurred';
            }

            showUserFriendlyError(message) {
                if (typeof showAlert === 'function') {
                    showAlert(message);
                } else {
                    console.error('User Error:', message);
                }
            }
        }

        // ✅ FIXED: Enhanced Application State Management
        class AppState {
            constructor() {
                // Core state
                this.img = null;
                this.originalImageData = null;
                this.textObjects = [];
                this.selectedTextIndex = -1;
                this.currentLang = 'en';
                this.currentFont = 'Vazirmatn';
                
                // Limits
                this.maxTextObjects = 3;
                this.maxCustomFonts = 3;
                this.customFontsCount = 0;
                
                // UI state
                this.fontPanels = [];
                this.loadedCustomFonts = new Map();
                this.currentModal = null;
                this.lastFocusedElement = null;
                
                // Interaction state
                this.isDraggingText = false;
                this.isDraggingCanvas = false;
                this.isPinching = false;
                this.initialPinchDistance = 0;
                this.lastFontSize = 50;
                
                // Canvas state with enhanced bounds
                this.canvasTransform = { x: 0, y: 0 };
                this.dragStart = { x: 0, y: 0 };
                this.lastPointer = { x: 0, y: 0 };
                this.momentum = { x: 0, y: 0 };
                this.isAnimating = false;
                this.canvasBounds = { left: 0, top: 0, right: 0, bottom: 0 };
                
                // Touch handling
                this.lastTapTime = 0;
                this.tapCount = 0;
                this.doubleTapDelay = 300;
                this.lastTouchTime = 0;
                this.touchCount = 0;
                this.lastCanvasTouchTime = 0;
                this.canvasTouchCount = 0;
                
                // UI feedback
                this.selectionBorderTimeout = null;
                this.borderFadeTimeout = null;
            }

            createTextObject(text = '', x = 0, y = 0) {
                return {
                    text: text,
                    x: x,
                    y: y,
                    width: 200,
                    height: 60,
                    fontSize: 50,
                    color: '#000000',
                    opacity: 1,
                    shadowBlur: 0,
                    strokeWidth: 0,
                    glowBlur: 0,
                    backdropColor: '#FFFFFF',
                    backdropOpacity: 0,
                    backdropRadius: 0,
                    backdropWidthPercentage: 0,
                    backdropHeightPercentage: 0,
                    font: this.currentFont
                };
            }

            resetImageState() {
                try {
                    this.textObjects.forEach((textObj, index) => {
                        if (DOM.canvas) {
                            textObj.x = (DOM.canvas.width - textObj.width) / 2;
                            textObj.y = (DOM.canvas.height - textObj.height) / 2 + (index * (DOM.canvas.height * 0.1));
                            textObj.width = Math.max(200, DOM.canvas.width * 0.3);
                            textObj.height = Math.max(60, DOM.canvas.height * 0.08);
                        }
                    });
                } catch (error) {
                    memoryManager.logError('IMAGE_STATE_RESET_ERROR', error);
                }
            }

            cleanup() {
                try {
                    // Clear timeouts
                    if (this.selectionBorderTimeout) {
                        clearTimeout(this.selectionBorderTimeout);
                        this.selectionBorderTimeout = null;
                    }
                    if (this.borderFadeTimeout) {
                        clearTimeout(this.borderFadeTimeout);
                        this.borderFadeTimeout = null;
                    }

                    // Clear references
                    this.img = null;
                    this.originalImageData = null;
                    this.textObjects = [];
                    this.fontPanels = [];
                    this.loadedCustomFonts.clear();

                    console.log('✅ AppState cleanup completed');
                } catch (error) {
                    console.error('❌ Error during AppState cleanup:', error);
                }
            }
        }

        // ✅ FIXED: Enhanced Crop State Management
        class CropState {
            constructor() {
                this.reset();
            }

            reset() {
                this.scale = 1;
                this.position = { x: 0, y: 0 };
                this.minScale = 1;
                this.maxScale = 5;
                this.initialScale = 1;
                this.isDragging = false;
                this.isPinching = false;
                this.lastTouchPos = { x: 0, y: 0 };
                this.bounds = { left: 0, top: 0, right: 0, bottom: 0 };
                this.originalImage = null;
            }
        }

        // ✅ FIXED: Enhanced DOM Element Management
        class DOMManager {
            constructor() {
                this.elements = {};
                this.batchSelectors = {};
                this.initializeElements();
            }

            initializeElements() {
                // Define all DOM selectors
                const selectors = {
                    // Core elements
                    dacoLoadingScreen: '#dacoLoadingScreen',
                    orientationLockOverlay: '#orientation-lock-overlay',
                    announcements: '#announcements',
                    
                    // Modals
                    quickActionModal: '#quickActionModal',
                    quickAddImage: '#quickAddImage',
                    quickAddText: '#quickAddText',
                    
                    // Crop modal
                    cropModal: '#cropModal',
                    cropViewport: '#cropViewport',
                    cropImage: '#cropImage',
                    cropLoading: '#cropLoading',
                    cropFrame: '#cropFrame',
                    zoomIn: '#zoomIn',
                    zoomOut: '#zoomOut',
                    zoomInfo: '#zoomInfo',
                    cropCancel: '#cropCancel',
                    cropConfirm: '#cropConfirm',
                    
                    // Download modal
                    downloadModal: '#downloadModal',
                    closeDownloadModal: '#closeDownloadModal',
                    saveToGalleryCard: '#saveToGalleryCard',
                    downloadTransparentCard: '#downloadTransparentCard',
                    
                    // Header
                    downloadHeaderBtn: '#downloadHeaderBtn',
                    imageInput: '#imageInput',
                    uploadImageBtn: '#uploadImageBtn',
                    deleteImageBtn: '#deleteImageBtn',
                    themeToggle: '#themeToggle',
                    langSwitch: '#langSwitch',
                    
                    // Canvas and main content
                    canvas: '#canvas',
                    photoPlaceholder: '#photo-placeholder',
                    canvasWrapper: '.canvas-wrapper',
                    verticalGuide: '.guide-line.vertical',
                    horizontalGuide: '.guide-line.horizontal',
                    
                    // Font and text controls
                    fontInput: '#fontInput',
                    fontSelector: '#fontSelector',
                    fontPanelsContainer: '#fontPanelsContainer',
                    addFontPanelBtn: '#addFontPanelBtn',
                    
                    // Sliders and controls
                    fontSizeSlider: '#fontSizeSlider',
                    fontSizeValue: '#fontSizeValue',
                    textColorGrid: '#textColorGrid',
                    bgColorGrid: '#bgColorGrid',
                    opacitySlider: '#opacitySlider',
                    opacityValue: '#opacityValue',
                    shadowSlider: '#shadowSlider',
                    shadowValue: '#shadowValue',
                    strokeSlider: '#strokeSlider',
                    strokeValue: '#strokeValue',
                    glowSlider: '#glowSlider',
                    glowValue: '#glowValue',
                    backdropOpacitySlider: '#backdropOpacitySlider',
                    backdropWidthSlider: '#backdropWidthSlider',
                    backdropHeightSlider: '#backdropHeightSlider',
                    backdropRadiusSlider: '#backdropRadiusSlider',
                    backdropOpacityValue: '#backdropOpacityValue',
                    backdropWidthValue: '#backdropWidthValue',
                    backdropHeightValue: '#backdropHeightValue',
                    backdropRadiusValue: '#backdropRadiusValue'
                };

                // Batch selectors for multiple elements
                this.batchSelectors = {
                    controlIcons: '.control-icon',
                    accordionPanels: '.accordion-panel',
                    closePanelBtns: '.close-panel'
                };

                // Initialize elements
                this.elements = {};
                this.validateAndAssignElements(selectors);
                this.validateAndAssignBatchElements();
            }

            validateAndAssignElements(selectors) {
                const missingElements = [];

                for (const [key, selector] of Object.entries(selectors)) {
                    const element = document.querySelector(selector);
                    if (element) {
                        this.elements[key] = element;
                    } else {
                        missingElements.push({ key, selector });
                    }
                }

                if (missingElements.length > 0) {
                    console.warn('⚠️ Missing DOM elements:', missingElements);
                }
            }

            validateAndAssignBatchElements() {
                for (const [key, selector] of Object.entries(this.batchSelectors)) {
                    const elements = document.querySelectorAll(selector);
                    this.elements[key] = elements;
                    
                    if (elements.length === 0) {
                        console.warn(`⚠️ No elements found for batch selector: ${selector}`);
                    }
                }
            }

            get(elementKey) {
                return this.elements[elementKey] || null;
            }

            validateCriticalElements() {
                const criticalElements = [
                    'canvas', 'imageInput', 'uploadImageBtn', 'themeToggle', 'langSwitch',
                    'downloadHeaderBtn', 'fontSelector', 'fontSizeSlider', 'textColorGrid',
                    'bgColorGrid', 'controlIcons'
                ];

                const missing = criticalElements.filter(key => {
                    const element = this.elements[key];
                    return !element || (key === 'controlIcons' && element.length === 0);
                });

                if (missing.length > 0) {
                    console.error('❌ Missing critical DOM elements:', missing);
                    return false;
                }

                console.log('✅ All critical DOM elements validated');
                return true;
            }
        }

        // ✅ FIXED: Enhanced Performance Monitor with Ultra-Fast Response
        class PerformanceMonitor {
            constructor() {
                this.isDrawScheduled = false;
                this.needsFullRedraw = true;
                this.lastDrawnState = null;
                this.drawCount = 0;
                this.lastPerformanceCheck = Date.now();
                this.pendingUpdates = new Set();
            }

            // ✅ FIXED: Ultra-Fast Draw Scheduling - ENHANCED VERSION
            scheduleDraw(forceFullRedraw = false) {
                if (forceFullRedraw) this.needsFullRedraw = true;
                
                if (!this.isDrawScheduled) {
                    this.isDrawScheduled = true;
                    // ✅ FIXED: حذف شرط اضافی برای render سریع‌تر
                    requestAnimationFrame(() => {
                        try {
                            canvasRenderer.drawCanvas();
                            this.cacheCurrentState();
                            this.needsFullRedraw = false;
                            this.drawCount++;
                        } catch (error) {
                            memoryManager.logError('DRAW_ERROR', error);
                        } finally {
                            this.isDrawScheduled = false;
                        }
                    });
                }
            }

            // ✅ FIXED: Instant UI Update Scheduling
            scheduleUIUpdate(elementId, updateFunction) {
                if (!this.pendingUpdates.has(elementId)) {
                    this.pendingUpdates.add(elementId);
                    requestAnimationFrame(() => {
                        try {
                            updateFunction();
                        } catch (error) {
                            memoryManager.logError('UI_UPDATE_ERROR', error);
                        } finally {
                            this.pendingUpdates.delete(elementId);
                        }
                    });
                }
            }
            
            cacheCurrentState() {
                if (!appState?.textObjects) return;
                
                this.lastDrawnState = JSON.stringify({
                    textObjects: appState.textObjects.map(t => ({
                        text: t.text, x: t.x, y: t.y, fontSize: t.fontSize, color: t.color
                    })),
                    hasImage: !!appState.img
                });
            }

            getPerformanceReport() {
                const now = Date.now();
                const duration = now - this.lastPerformanceCheck;
                const drawsPerSecond = duration > 0 ? (this.drawCount * 1000 / duration).toFixed(2) : 0;
                
                return {
                    drawCount: this.drawCount,
                    drawsPerSecond,
                    memoryUsage: memoryManager.getMemoryUsage(),
                    duration: duration
                };
            }

            reset() {
                this.drawCount = 0;
                this.lastPerformanceCheck = Date.now();
            }
        }

        // Initialize core systems
        const memoryManager = new MemoryManager();
        const errorBoundary = new ErrorBoundary(memoryManager);
        const appState = new AppState();
        const cropState = new CropState();
        const DOM = new DOMManager();
        const performanceMonitor = new PerformanceMonitor();

        // ✅ FIXED: Enhanced Canvas Renderer
        class CanvasRenderer {
            constructor() {
                this.measurementCanvas = document.createElement('canvas');
                this.measurementCtx = this.measurementCanvas.getContext('2d');
                this.ctx = this.initializeCanvasContext();
            }

            initializeCanvasContext() {
                try {
                    const canvas = DOM.get('canvas');
                    if (!canvas) {
                        throw new Error('Canvas element not found');
                    }

                    const context = canvas.getContext('2d');
                    if (!context) {
                        throw new Error('Failed to get 2D context');
                    }

                    return context;
                } catch (error) {
                    memoryManager.logError('CANVAS_CONTEXT_ERROR', error);
                    return null;
                }
            }

            drawCanvas() {
                try {
                    if (!this.ctx || !DOM.get('canvas')) return;
                    
                    if (!appState.img && appState.textObjects.every(t => !t.text.trim())) {
                        this.drawEmptyCanvas();
                        return;
                    }
                    
                    if (DOM.get('photoPlaceholder')) {
                        DOM.get('photoPlaceholder').style.display = 'none';
                    }
                    
                    this.ctx.clearRect(0, 0, DOM.get('canvas').width, DOM.get('canvas').height);
                    
                    if (appState.img) {
                        this.ctx.imageSmoothingEnabled = true;
                        this.ctx.imageSmoothingQuality = 'high';
                        this.ctx.drawImage(appState.img, 0, 0, DOM.get('canvas').width, DOM.get('canvas').height);
                    } else {
                        this.ctx.fillStyle = "#FFFFFF";
                        this.ctx.fillRect(0, 0, DOM.get('canvas').width, DOM.get('canvas').height);
                    }
                    
                    this.updateCanvasWrapperSize();
                    this.updateCanvasBounds();
                    this.drawTextObjects();
                    
                } catch (error) {
                    memoryManager.logError('CANVAS_DRAW_ERROR', error);
                }
            }

            drawEmptyCanvas() {
                try {
                    const canvas = DOM.get('canvas');
                    if (!canvas || !this.ctx) return;
                    
                    const targetRatio = 9/16;
                    const container = document.querySelector('.canvas-container');
                    if (!container) return;
                    
                    const containerRect = container.getBoundingClientRect();
                    
                    let canvasWidth, canvasHeight;
                    const containerAspect = containerRect.width / containerRect.height;
                    
                    if (targetRatio > containerAspect) {
                        canvasWidth = Math.min(containerRect.width * 0.75, 350);
                        canvasHeight = canvasWidth / targetRatio;
                    } else {
                        canvasHeight = Math.min(containerRect.height * 0.75, 500);
                        canvasWidth = canvasHeight * targetRatio;
                    }
                    
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    
                    const canvasWrapper = DOM.get('canvasWrapper');
                    if (canvasWrapper) {
                        canvasWrapper.style.width = canvasWidth + 'px';
                        canvasWrapper.style.height = canvasHeight + 'px';
                    }
                    
                    this.ctx.fillStyle = "#f0f0f0";
                    this.ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    if (DOM.get('photoPlaceholder')) {
                        DOM.get('photoPlaceholder').style.display = 'flex';
                    }
                    
                    this.updateCanvasBounds();
                    
                } catch (error) {
                    memoryManager.logError('EMPTY_CANVAS_DRAW_ERROR', error);
                }
            }

            updateCanvasWrapperSize() {
                const canvasWrapper = DOM.get('canvasWrapper');
                if (!canvasWrapper) return;
                
                const targetRatio = 9/16;
                const container = document.querySelector('.canvas-container');
                if (!container) return;
                
                const containerRect = container.getBoundingClientRect();
                
                let displayWidth, displayHeight;
                const containerAspect = containerRect.width / containerRect.height;
                
                if (targetRatio > containerAspect) {
                    displayWidth = Math.min(containerRect.width * 0.9, 600);
                    displayHeight = displayWidth / targetRatio;
                } else {
                    displayHeight = Math.min(containerRect.height * 0.9, 700);
                    displayWidth = displayHeight * targetRatio;
                }
                
                canvasWrapper.style.width = Math.round(displayWidth) + 'px';
                canvasWrapper.style.height = Math.round(displayHeight) + 'px';
            }

            // ✅ FIXED: Enhanced Canvas Bounds with Proper Right Constraint
            updateCanvasBounds() {
                try {
                    const canvasWrapper = DOM.get('canvasWrapper');
                    if (!canvasWrapper) return;
                    
                    const container = document.querySelector('.canvas-container');
                    if (!container) return;

                    const wrapperWidth = canvasWrapper.offsetWidth;
                    const wrapperHeight = canvasWrapper.offsetHeight;
                    const containerWidth = container.offsetWidth;
                    const containerHeight = container.offsetHeight;

                    if (!wrapperWidth || !containerWidth || !wrapperHeight || !containerHeight) {
                        return;
                    }

                    const minVisibleWidth = wrapperWidth / 3;
                    const minVisibleHeight = wrapperHeight / 3;

                    const limitX = (containerWidth / 2) + (wrapperWidth / 2) - minVisibleWidth;
                    const limitY = (containerHeight / 2) + (wrapperHeight / 2) - minVisibleHeight;

                    appState.canvasBounds = {
                        left: -limitX,
                        right: limitX,
                        top: -limitY,
                        bottom: limitY
                    };

                } catch (error) {
                    memoryManager.logError('BOUNDS_UPDATE_ERROR', error);
                }
            }

            drawTextObjects() {
                if (!this.ctx) return;
                
                try {
                    appState.textObjects.forEach((textObj, index) => {
                        if (!textObj.text.trim()) return;
                        this.drawTextObject(textObj, index === appState.selectedTextIndex);
                    });
                    
                    this.ctx.globalAlpha = 1;
                    this.ctx.shadowBlur = 0;
                } catch (error) {
                    memoryManager.logError('TEXT_OBJECTS_DRAW_ERROR', error);
                }
            }

            drawTextObject(textObj, isSelected = false) {
                if (!this.ctx) return;
                
                try {
                    const textLines = textObj.text.split('\n');
                    const isRTLText = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F]/.test(textObj.text);
                    
                    let baseFontSize = textObj.fontSize;
                    let calculatedFontSize = Math.max(16, (baseFontSize / 100) * Math.min(DOM.get('canvas').width, DOM.get('canvas').height) * 0.12);
                    
                    this.ctx.font = `${calculatedFontSize}px ${textObj.font}`;
                    
                    let maxTextWidth = 0;
                    textLines.forEach(line => {
                        const metrics = this.measureText(line, textObj.font, calculatedFontSize);
                        maxTextWidth = Math.max(maxTextWidth, metrics.width);
                    });
                    
                    if (maxTextWidth > DOM.get('canvas').width * 0.95) {
                        calculatedFontSize *= (DOM.get('canvas').width * 0.95) / maxTextWidth;
                        calculatedFontSize = Math.max(12, calculatedFontSize);
                    }
                    
                    this.ctx.font = `${calculatedFontSize}px ${textObj.font}`;
                    
                    maxTextWidth = 0;
                    textLines.forEach(line => {
                        const metrics = this.measureText(line, textObj.font, calculatedFontSize);
                        maxTextWidth = Math.max(maxTextWidth, metrics.width);
                    });
                    
                    const lineHeight = calculatedFontSize * 1.3;
                    const backdropPaddingX = (textObj.backdropWidthPercentage / 100) * maxTextWidth;
                    const backdropPaddingY = (textObj.backdropHeightPercentage / 100) * (lineHeight * textLines.length);
                    
                    textObj.width = maxTextWidth + backdropPaddingX;
                    textObj.height = (lineHeight * textLines.length) + backdropPaddingY;
                    
                    textObj.x = Math.max(0, Math.min(textObj.x, DOM.get('canvas').width - textObj.width));
                    textObj.y = Math.max(0, Math.min(textObj.y, DOM.get('canvas').height - textObj.height));

                    if (textObj.backdropOpacity > 0) {
                        this.drawTextBackdrop(textObj, calculatedFontSize);
                    }
                    
                    this.drawTextContent(textObj, textLines, calculatedFontSize, lineHeight, isRTLText);
                    
                    if (isSelected) {
                        this.drawSelectionBorder(textObj, calculatedFontSize);
                    }
                } catch (error) {
                    memoryManager.logError('TEXT_OBJECT_DRAW_ERROR', error);
                }
            }

            drawTextBackdrop(textObj, fontSize) {
                if (!this.ctx) return;
                
                this.ctx.fillStyle = textObj.backdropColor;
                this.ctx.globalAlpha = textObj.backdropOpacity;
                
                const radius = Math.max(0, (textObj.backdropRadius / 100) * Math.min(textObj.width, textObj.height) / 2);
                
                if (radius > 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(textObj.x + radius, textObj.y);
                    this.ctx.arcTo(textObj.x + textObj.width, textObj.y, textObj.x + textObj.width, textObj.y + textObj.height, radius);
                    this.ctx.arcTo(textObj.x + textObj.width, textObj.y + textObj.height, textObj.x, textObj.y + textObj.height, radius);
                    this.ctx.arcTo(textObj.x, textObj.y + textObj.height, textObj.x, textObj.y, radius);
                    this.ctx.arcTo(textObj.x, textObj.y, textObj.x + textObj.width, textObj.y, radius);
                    this.ctx.closePath();
                    this.ctx.fill();
                } else {
                    this.ctx.fillRect(textObj.x, textObj.y, textObj.width, textObj.height);
                }
                
                this.ctx.globalAlpha = 1;
            }

            drawTextContent(textObj, textLines, fontSize, lineHeight, isRTL) {
                if (!this.ctx) return;
                
                this.ctx.font = `${fontSize}px ${textObj.font}`;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                
                this.ctx.shadowColor = `rgba(0,0,0,0.5)`;
                this.ctx.shadowBlur = Math.max(0, textObj.shadowBlur * (fontSize / 50));
                this.ctx.strokeStyle = `rgb(0,0,0)`;
                this.ctx.lineWidth = Math.max(0, textObj.strokeWidth * (fontSize / 50));
                this.ctx.lineJoin = 'round';
                this.ctx.lineCap = 'round';
                
                let lineY = textObj.y + (textObj.height / 2) - (((textLines.length - 1) * lineHeight) / 2);
                
                textLines.forEach(line => {
                    const x = textObj.x + textObj.width / 2;
                    
                    if (textObj.strokeWidth > 0) {
                        this.ctx.strokeText(line, x, lineY);
                    }
                    
                    if (textObj.glowBlur > 0) {
                        this.ctx.shadowColor = textObj.color;
                        this.ctx.shadowBlur = Math.max(0, textObj.glowBlur * (fontSize / 50));
                    }
                    
                    this.ctx.fillStyle = textObj.color;
                    this.ctx.globalAlpha = Math.max(0, Math.min(1, textObj.opacity));
                    
                    this.renderTextWithBiDiSupport(line, x, lineY, textObj.font, isRTL);
                    
                    this.ctx.shadowBlur = Math.max(0, textObj.shadowBlur * (fontSize / 50));
                    this.ctx.shadowColor = `rgba(0,0,0,0.5)`;
                    
                    lineY += lineHeight;
                });
            }

            drawSelectionBorder(textObj, fontSize) {
                if (!this.ctx) return;
                
                this.ctx.globalAlpha = 1;
                
                const shouldFade = appState.borderFadeTimeout !== null;
                const borderOpacity = shouldFade ? 0.2 : 0.8;
                
                this.ctx.strokeStyle = `rgba(27, 59, 20, ${borderOpacity})`;
                this.ctx.lineWidth = Math.max(3, fontSize / 20);
                this.ctx.setLineDash([Math.max(8, fontSize / 8), Math.max(4, fontSize / 16)]);
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                const cornerRadius = Math.max(8, fontSize / 8);
                const padding = Math.max(4, fontSize / 16);
                const x = textObj.x - padding;
                const y = textObj.y - padding;
                const width = textObj.width + padding * 2;
                const height = textObj.height + padding * 2;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x + cornerRadius, y);
                this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);
                this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);
                this.ctx.arcTo(x, y + height, x, y, cornerRadius);
                this.ctx.arcTo(x, y, x + width, y, cornerRadius);
                this.ctx.closePath();
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
            }

            renderTextWithBiDiSupport(text, x, y, font, isRTL = false) {
                if (!this.ctx) return;
                
                const currentDirection = this.ctx.direction;
                const currentTextAlign = this.ctx.textAlign;
                
                if (isRTL || /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F]/.test(text)) {
                    this.ctx.direction = 'rtl';
                } else {
                    this.ctx.direction = 'ltr';
                }
                
                this.ctx.fillText(text, x, y);
                
                this.ctx.direction = currentDirection;
                this.ctx.textAlign = currentTextAlign;
            }

            measureText(text, font, fontSize) {
                try {
                    this.measurementCtx.font = `${fontSize}px ${font}`;
                    return this.measurementCtx.measureText(text);
                } catch (error) {
                    memoryManager.logError('TEXT_MEASURE_ERROR', error);
                    return { width: 0 };
                }
            }
        }

        // Initialize canvas renderer
        const canvasRenderer = new CanvasRenderer();

        // ✅ FIXED: Enhanced Translation System
        const translations = {
            en: {
                initialCanvasText: '',
                alertImage: 'Please upload an image first.',
                alertText: 'Please enter text to download.',
                alertFont: 'You can add maximum 3 custom fonts.',
                alertFontSuccess: (fileName) => `Font ${fileName} loaded successfully!`,
                alertFontError: (message) => `Font loading failed. Using default font instead.`,
                copySuccess: 'Image copied to clipboard successfully!',
                maxPanels: 'You can have maximum 3 text panels.',
                textPlaceholder: 'Write your text',
                saveSuccess: 'High-quality 9:16 image saved perfectly!',
                downloadSuccess: 'High-quality file downloaded!',
                saveError: 'Error saving image',
                downloadError: 'Error downloading',
                fileDownloaded: 'File downloaded',
                orientationMessage: 'Please rotate your device to portrait mode for the best experience.',
                fontFallback: 'Font loading failed, using default font.',
                memoryError: 'Insufficient memory for this operation',
                networkError: 'Network connection error',
                fileError: 'File processing error'
            },
            fa: {
                initialCanvasText: '',
                alertImage: 'لطفاً ابتدا یک عکس بارگذاری کنید.',
                alertText: 'لطفاً متنی برای دانلود وارد کنید.',
                alertFont: 'شما می‌توانید حداکثر ۳ فونت سفارشی اضافه کنید.',
                alertFontSuccess: (fileName) => `فونت ${fileName} با موفقیت بارگذاری شد!`,
                alertFontError: (message) => `بارگذاری فونت ناموفق بود. از فونت پیش‌فرض استفاده می‌شود.`,
                copySuccess: 'تصویر با موفقیت به کلیپ‌بورد کپی شد!',
                maxPanels: 'حداکثر ۳ پنل متن می‌توانید داشته باشید.',
                textPlaceholder: 'متن خود را بنویسید',
                saveSuccess: 'عکس ۹:۱۶ با کیفیت بالا ذخیره شد!',
                downloadSuccess: 'فایل با کیفیت بالا دانلود شد!',
                saveError: 'خطا در ذخیره سازی',
                downloadError: 'خطا در دانلود',
                fileDownloaded: 'فایل دانلود شد',
                orientationMessage: 'لطفاً دستگاه خود را به حالت عمودی بچرخانید تا بهترین تجربه را داشته باشید.',
                fontFallback: 'بارگذاری فونت ناموفق بود، از فونت پیش‌فرض استفاده می‌شود.',
                memoryError: 'حافظه کافی برای این عملیات وجود ندارد',
                networkError: 'خطا در اتصال به شبکه',
                fileError: 'خطا در پردازش فایل'
            },
            ar: {
                initialCanvasText: '',
                alertImage: 'يرجى تحميل صورة أولاً.',
                alertText: 'يرجى إدخال نص للتحميل.',
                alertFont: 'يمكنك إضافة حد أقصى 3 خطوط مخصصة.',
                alertFontSuccess: (fileName) => `تم تحميل الخط ${fileName} بنجاح!`,
                alertFontError: (message) => `فشل تحميل الخط. سيتم استخدام الخط الافتراضي بدلاً من ذلك.`,
                copySuccess: 'تم نسخ الصورة إلى الحافظة بنجاح!',
                maxPanels: 'يمكنك الحصول على حد أقصى 3 لوحات نص.',
                textPlaceholder: 'اكتب نصك',
                saveSuccess: 'تم حفظ صورة 9:16 عالية الجودة بشكل مثالي!',
                downloadSuccess: 'تم تحميل الملف عالي الجودة!',
                saveError: 'خطأ في حفظ الصورة',
                downloadError: 'خطأ في التحميل',
                fileDownloaded: 'تم تحميل الملف',
                orientationMessage: 'يرجى تدوير جهازك إلى الوضع العمودي للحصول على أفضل تجربة.',
                fontFallback: 'فشل تحميل الخط، سيتم استخدام الخط الافتراضي.',
                memoryError: 'ذاكرة غير كافية لهذه العملية',
                networkError: 'خطأ في اتصال الشبكة',
                fileError: 'خطأ في معالجة الملف'
            }
        };

        // Number formatting utilities
        const numToFa = (num) => String(num).replace(/\d/g, d => '۰۱۲۳۴۵۶۷۸۹'[d]);
        const numToAr = (num) => String(num).replace(/\d/g, d => '٠١٢٣٤٥٦٧٨٩'[d]);
        const numToEn = (num) => String(num);

        // ✅ FIXED: Enhanced Font Management System
        class FontManager {
            constructor() {
                this.fontFamilies = [
                    { name: 'Vazirmatn', weights: [100, 200, 300, 400, 500, 600, 700, 800, 900] },
                    { name: 'Lalezar', weights: [400] },
                    { name: 'Amiri', weights: [400, 700] },
                    { name: 'Markazi Text', weights: [400, 500, 600, 700] },
                    { name: 'Noto Naskh Arabic', weights: [400, 500, 600, 700] },
                    { name: 'Shabnam', weights: [400, 700] }
                ];
            }

            async preloadFonts() {
                try {
                    const fontPromises = [];
                    const maxRetries = 2;
                    
                    this.fontFamilies.forEach(fontFamily => {
                        fontFamily.weights.forEach(weight => {
                            const fontPromise = this.retryOperation(
                                () => document.fonts.load(`${weight} 16px ${fontFamily.name}`),
                                maxRetries
                            ).then(() => {
                                console.log(`✅ Font loaded: ${fontFamily.name} ${weight}`);
                            }).catch(error => {
                                console.warn(`⚠️ Font load failed: ${fontFamily.name} ${weight}`, error);
                            });
                            fontPromises.push(fontPromise);
                        });
                    });
                    
                    await Promise.allSettled([...fontPromises, document.fonts.ready]);
                    console.log('✅ All fonts successfully preloaded and ready');
                    return true;
                } catch (error) {
                    console.warn('⚠️ Some fonts failed to preload:', error);
                    memoryManager.logError('FONT_PRELOAD_ERROR', error);
                    return false;
                }
            }

            async retryOperation(operation, maxRetries = 3, delay = 1000) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await operation();
                    } catch (error) {
                        if (i === maxRetries - 1) throw error;
                        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                    }
                }
            }

            async loadCustomFont(file, fileName) {
                try {
                    if (appState.customFontsCount >= appState.maxCustomFonts) {
                        throw new Error('MAX_CUSTOM_FONTS_EXCEEDED');
                    }

                    if (file.size > 10 * 1024 * 1024) { // 10MB limit
                        throw new Error('FILE_TOO_LARGE');
                    }

                    const fontName = `CustomFont_${Date.now()}`;
                    const arrayBuffer = await this.readFileAsArrayBuffer(file);
                    
                    const font = new FontFace(fontName, arrayBuffer);
                    
                    // Load with timeout
                    const loadPromise = font.load();
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('FONT_LOAD_TIMEOUT')), 10000)
                    );
                    
                    await Promise.race([loadPromise, timeoutPromise]);
                    
                    // Test the font
                    const testCanvas = document.createElement('canvas');
                    const testCtx = testCanvas.getContext('2d');
                    testCtx.font = `16px ${fontName}`;
                    testCtx.fillText('Test', 0, 0);
                    
                    document.fonts.add(font);
                    appState.loadedCustomFonts.set(fontName, fileName);
                    
                    const fontSelector = DOM.get('fontSelector');
                    if (fontSelector) {
                        const option = new Option(fileName, fontName);
                        fontSelector.add(option);
                        fontSelector.value = fontName;
                    }
                    
                    appState.customFontsCount++;
                    appState.currentFont = fontName;
                    
                    if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                        appState.textObjects[appState.selectedTextIndex].font = fontName;
                    }
                    
                    performanceMonitor.scheduleDraw(true);
                    showAlert(translations[appState.currentLang].alertFontSuccess(fileName));
                    
                    return true;
                } catch (error) {
                    console.error('Font loading error:', error);
                    this.applyFontFallback(fileName, error);
                    return false;
                }
            }

            async readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('FILE_READ_ERROR'));
                    reader.readAsArrayBuffer(file);
                });
            }

            applyFontFallback(fileName, error) {
                try {
                    memoryManager.logError('FONT_LOAD_ERROR', error);
                    
                    const fallbackFont = 'Vazirmatn';
                    const fontSelector = DOM.get('fontSelector');
                    if (fontSelector) fontSelector.value = fallbackFont;
                    appState.currentFont = fallbackFont;
                    
                    if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                        appState.textObjects[appState.selectedTextIndex].font = fallbackFont;
                    }
                    
                    performanceMonitor.scheduleDraw(true);
                    
                    let errorMessage = translations[appState.currentLang].fontFallback;
                    if (error.message === 'FONT_LOAD_TIMEOUT') {
                        errorMessage = appState.currentLang === 'fa' ? 'بارگذاری فونت طولانی شد، از فونت پیش‌فرض استفاده می‌شود' :
                                      appState.currentLang === 'ar' ? 'استغرق تحميل الخط وقتاً طويلاً، سيتم استخدام الخط الافتراضي' :
                                      'Font loading took too long, using default font';
                    } else if (error.message === 'MAX_CUSTOM_FONTS_EXCEEDED') {
                        errorMessage = translations[appState.currentLang].alertFont;
                    } else if (error.message === 'FILE_TOO_LARGE') {
                        errorMessage = appState.currentLang === 'fa' ? 'حجم فونت نباید بیشتر از ۱۰ مگابایت باشد' :
                                      appState.currentLang === 'ar' ? 'يجب ألا يتجاوز حجم الخط 10 ميجابايت' :
                                      'Font size should not exceed 10MB';
                    }
                    showAlert(errorMessage);
                } catch (fallbackError) {
                    console.error('Error in font fallback:', fallbackError);
                }
            }
        }

        // Initialize font manager
        const fontManager = new FontManager();

        // ✅ FIXED: Enhanced Accessibility Manager
        class AccessibilityManager {
            constructor() {
                this.currentModal = null;
                this.lastFocusedElement = null;
                this.setupGlobalAccessibility();
            }

            setupGlobalAccessibility() {
                // Setup screen reader announcements
                this.announcementsElement = DOM.get('announcements');
                
                // Setup focus management
                this.setupFocusManagement();
                
                // Setup keyboard navigation
                this.setupKeyboardNavigation();
            }

            setupFocusManagement() {
                // Store focus when modals open
                memoryManager.addEventListener(document, 'focusin', (e) => {
                    if (!this.currentModal && e.target !== document.body) {
                        this.lastFocusedElement = e.target;
                    }
                });

                // Trap focus in modals
                memoryManager.addEventListener(document, 'keydown', (e) => {
                    if (e.key === 'Tab' && this.currentModal) {
                        this.trapFocusInModal(e);
                    }
                });
            }

            setupKeyboardNavigation() {
                // Global keyboard shortcuts
                memoryManager.addEventListener(document, 'keydown', (e) => {
                    if (e.key === 'Escape' && this.currentModal) {
                        this.closeCurrentModal();
                    }
                });
            }

            trapFocusInModal(e) {
                const modal = document.getElementById(this.currentModal);
                if (!modal) return;

                const focusableElements = modal.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                
                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];

                if (e.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        e.preventDefault();
                        lastFocusable.focus();
                    }
                } else {
                    if (document.activeElement === lastFocusable) {
                        e.preventDefault();
                        firstFocusable.focus();
                    }
                }
            }

            openModal(modalId) {
                try {
                    const modal = document.getElementById(modalId);
                    if (!modal) return false;

                    // Store current focus
                    this.lastFocusedElement = document.activeElement;
                    this.currentModal = modalId;

                    // Show modal
                    modal.classList.add('active');
                    modal.setAttribute('aria-hidden', 'false');

                    // Focus first focusable element
                    const firstFocusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                    if (firstFocusable) {
                        setTimeout(() => firstFocusable.focus(), 100);
                    }

                    // Announce to screen readers
                    this.announce(`${modalId} modal opened`);

                    return true;
                } catch (error) {
                    memoryManager.logError('MODAL_OPEN_ERROR', error);
                    return false;
                }
            }

            closeModal(modalId) {
                try {
                    const modal = document.getElementById(modalId);
                    if (!modal) return false;

                    // Hide modal
                    modal.classList.remove('active');
                    modal.setAttribute('aria-hidden', 'true');
                    
                    this.currentModal = null;

                    // Restore focus
                    if (this.lastFocusedElement) {
                        setTimeout(() => {
                            try {
                                this.lastFocusedElement.focus();
                            } catch (e) {
                                // Element might not be focusable anymore
                                document.body.focus();
                            }
                        }, 100);
                    }

                    // Announce to screen readers
                    this.announce(`${modalId} modal closed`);

                    return true;
                } catch (error) {
                    memoryManager.logError('MODAL_CLOSE_ERROR', error);
                    return false;
                }
            }

            closeCurrentModal() {
                if (this.currentModal) {
                    this.closeModal(this.currentModal);
                }
            }

            announce(message) {
                if (this.announcementsElement) {
                    this.announcementsElement.textContent = message;
                    setTimeout(() => {
                        this.announcementsElement.textContent = '';
                    }, 1000);
                }
            }

            setAriaLabel(element, label) {
                if (element) {
                    element.setAttribute('aria-label', label);
                }
            }

            setAriaDescribedBy(element, id) {
                if (element) {
                    element.setAttribute('aria-describedby', id);
                }
            }
        }

        // Initialize accessibility manager
        const accessibilityManager = new AccessibilityManager();

        // ✅ FIXED: Enhanced Alert System
        function showAlert(message) {
            try {
                const modal = document.createElement('div');
                modal.className = 'custom-alert-modal';
                modal.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; z-index:10000; backdrop-filter: blur(10px);';
                modal.setAttribute('role', 'dialog');
                modal.setAttribute('aria-labelledby', 'alert-message');
                modal.setAttribute('aria-modal', 'true');
                
                const isDark = document.body.classList.contains('night-mode');
                const bgColor = isDark ? 'rgba(21, 46, 17, 0.95)' : 'rgba(255, 243, 227, 0.95)';
                const textColor = isDark ? '#fff3e3' : '#152e11';
                const borderColor = isDark ? 'rgba(255, 243, 227, 0.2)' : 'rgba(21, 46, 17, 0.2)';
                
                const successIcon = `<div class="success-icon" style="width: 50px; height: 50px; border-radius: 50%; background: var(--orange-main); display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; animation: successPulse 0.6s ease-out;" aria-hidden="true">
                    <svg style="width: 24px; height: 24px; stroke: white; stroke-width: 3;" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                </div>`;
                
                const closeButton = document.createElement('button');
                closeButton.innerHTML = appState.currentLang === 'fa' ? 'باشه' : appState.currentLang === 'ar' ? 'حسناً' : 'OK';
                closeButton.style.cssText = `background: var(--orange-main); color: white; border: none; padding: 15px 30px; border-radius: 15px; cursor: pointer; font-family: 'Vazirmatn', sans-serif; font-weight: 600; font-size: 1rem; transition: all 0.3s ease; min-width: 120px; box-shadow: 0 5px 20px rgba(255, 110, 65, 0.4);`;
                closeButton.setAttribute('aria-label', 'Close alert');
                
                closeButton.addEventListener('mouseenter', () => {
                    closeButton.style.background = 'var(--orange-dark)';
                    closeButton.style.transform = 'translateY(-2px)';
                });
                
                closeButton.addEventListener('mouseleave', () => {
                    closeButton.style.background = 'var(--orange-main)';
                    closeButton.style.transform = 'translateY(0)';
                });
                
                closeButton.addEventListener('click', () => modal.remove());
                
                modal.innerHTML = `
                    <div style="background: ${bgColor}; padding: 30px; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.5); max-width: 380px; width: 90%; text-align: center; border: 1px solid ${borderColor}; backdrop-filter: blur(20px); transform: scale(0.9); animation: modalZoomIn 0.3s ease-out forwards;">
                        ${message.includes('ذخیره') || message.includes('saved') || message.includes('حفظ') ? successIcon : ''}
                        <p id="alert-message" style="color: ${textColor}; margin-bottom: 25px; font-family: 'Vazirmatn', sans-serif; line-height: 1.6; font-size: 1.1rem; font-weight: 500;">${message}</p>
                    </div>
                `;
                
                modal.querySelector('div').appendChild(closeButton);
                document.body.appendChild(modal);
                
                // Focus the close button for accessibility
                setTimeout(() => closeButton.focus(), 100);
                
                // Handle escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
                
                // Auto-remove after timeout
                setTimeout(() => {
                    if (modal.parentElement) {
                        modal.style.opacity = '0';
                        modal.style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            modal.remove();
                            document.removeEventListener('keydown', handleEscape);
                        }, 300);
                    }
                }, 4000);
                
                // Announce to screen readers
                accessibilityManager.announce(message);
                
            } catch (error) {
                console.error('Error showing alert:', error);
                console.log('Alert message:', message);
            }
        }

        // ✅ FIXED: Enhanced Language Manager
        class LanguageManager {
            constructor() {
                this.currentLang = 'en';
                this.supportedLanguages = ['en', 'fa', 'ar'];
            }

            switchLanguage(lang) {
                try {
                    if (!this.supportedLanguages.includes(lang)) {
                        console.warn(`Unsupported language: ${lang}`);
                        return false;
                    }

                    this.currentLang = lang;
                    appState.currentLang = lang;
                    
                    document.body.setAttribute('data-lang', lang);
                    document.documentElement.setAttribute('lang', lang);
                    
                    // Update all translatable elements
                    const elements = document.querySelectorAll('[data-fa][data-en][data-ar]');
                    elements.forEach(el => {
                        const text = el.getAttribute(`data-${lang}`);
                        if (text) {
                            if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'textarea')) {
                                el.placeholder = text;
                            } else if (el.tagName === 'TEXTAREA') {
                                el.placeholder = text;
                            } else {
                                el.textContent = text;
                            }
                        }
                    });
                    
                    // Update font panel placeholders
                    appState.fontPanels.forEach(panel => {
                        const input = panel.querySelector('.font-text-input');
                        if (input) {
                            input.placeholder = translations[lang].textPlaceholder;
                        }
                    });
                    
                    // Update slider values
                    uiManager.updateSliderValues();
                    
                    // Announce language change
                    accessibilityManager.announce(`Language changed to ${lang}`);
                    
                    console.log(`✅ Language switched to: ${lang}`);
                    return true;
                } catch (error) {
                    memoryManager.logError('LANGUAGE_SWITCH_ERROR', error);
                    return false;
                }
            }

            getNextLanguage() {
                const currentIndex = this.supportedLanguages.indexOf(this.currentLang);
                const nextIndex = (currentIndex + 1) % this.supportedLanguages.length;
                return this.supportedLanguages[nextIndex];
            }

            translateText(key, ...args) {
                const translation = translations[this.currentLang]?.[key];
                if (typeof translation === 'function') {
                    return translation(...args);
                }
                return translation || translations.en[key] || key;
            }
        }

        // Initialize language manager
        const languageManager = new LanguageManager();

        // ✅ FIXED: Enhanced UI Manager with Ultra-Fast Response
        class UIManager {
            constructor() {
                this.colorPalette = [
                    '#000000', '#4b5563', '#6b7280', '#9ca3af', '#d1d5db', '#ffffff',
                    '#ef4444', '#f87171', '#f97316', '#fb923c', '#eab308', '#facc15',
                    '#84cc16', '#a3e635', '#22c55e', '#4ade80', '#14b8a6', '#2dd4bf',
                    '#06b6d4', '#22d3ee', '#3b82f6', '#60a5fa', '#8b5cf6', '#a78bfa',
                    '#d946ef', '#e879f9', '#ec4899', '#f472b6'
                ];
                this.updateCache = new Map();
            }

            createColorGrid(container, onColorSelect) {
                try {
                    if (!container) return false;
                    
                    container.innerHTML = '';
                    container.setAttribute('role', 'group');
                    container.setAttribute('aria-label', 'Color selection');
                    
                    this.colorPalette.forEach((color, index) => {
                        const swatch = document.createElement('button');
                        swatch.className = 'color-grid-swatch';
                        swatch.style.backgroundColor = color;
                        swatch.dataset.color = color;
                        swatch.setAttribute('aria-label', `Select color ${color}`);
                        swatch.setAttribute('title', color);
                        swatch.type = 'button';
                        
                        memoryManager.addEventListener(swatch, 'click', () => {
                            try {
                                container.querySelectorAll('.color-grid-swatch').forEach(s => s.classList.remove('active'));
                                swatch.classList.add('active');
                                onColorSelect(color);
                                accessibilityManager.announce(`Color ${color} selected`);
                            } catch (error) {
                                memoryManager.logError('COLOR_SELECT_ERROR', error);
                            }
                        });
                        
                        memoryManager.addEventListener(swatch, 'keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                swatch.click();
                            }
                        });
                        
                        container.appendChild(swatch);
                    });
                    
                    console.log(`✅ Color grid created with ${this.colorPalette.length} colors`);
                    return true;
                } catch (error) {
                    memoryManager.logError('COLOR_GRID_ERROR', error);
                    return false;
                }
            }

            // ✅ FIXED: Lightning-Fast Panel Opening
            openPanel(panelId) {
                try {
                    const accordionPanels = DOM.get('accordionPanels');
                    const controlIcons = DOM.get('controlIcons');
                    
                    // Batch DOM updates
                    if (accordionPanels) {
                        accordionPanels.forEach(p => p.classList.remove('active'));
                    }
                    if (controlIcons) {
                        controlIcons.forEach(i => i.classList.remove('active'));
                    }
                    
                    const panel = document.getElementById(panelId + 'Panel');
                    const icon = document.querySelector(`[data-panel="${panelId}"]`);
                    
                    // ✅ Use faster class manipulation
                    requestAnimationFrame(() => {
                        if (panel) {
                            panel.classList.add('active');
                            panel.setAttribute('aria-hidden', 'false');
                            panel.scrollTop = 0;
                        }
                        if (icon) {
                            icon.classList.add('active');
                            icon.setAttribute('aria-expanded', 'true');
                        }
                    });
                    
                    accessibilityManager.announce(`${panelId} panel opened`);
                    return true;
                } catch (error) {
                    memoryManager.logError('PANEL_OPEN_ERROR', error);
                    return false;
                }
            }

            closePanel(panelId) {
                try {
                    const panel = document.getElementById(panelId + 'Panel');
                    const icon = document.querySelector(`[data-panel="${panelId}"]`);
                    
                    if (panel) {
                        panel.classList.remove('active');
                        panel.setAttribute('aria-hidden', 'true');
                    }
                    if (icon) {
                        icon.classList.remove('active');
                        icon.setAttribute('aria-expanded', 'false');
                    }
                    
                    accessibilityManager.announce(`${panelId} panel closed`);
                    return true;
                } catch (error) {
                    memoryManager.logError('PANEL_CLOSE_ERROR', error);
                    return false;
                }
            }

            // ✅ FIXED: Ultra-Fast Slider Value Updates - ENHANCED VERSION
            updateSliderValues() {
                try {
                    const numFormat = appState.currentLang === 'fa' ? numToFa : 
                                     appState.currentLang === 'ar' ? numToAr : numToEn;
                    const percentSymbol = appState.currentLang === 'fa' ? '٪' : 
                                         appState.currentLang === 'ar' ? '٪' : '%';
                    
                    const updates = [
                        { slider: DOM.get('fontSizeSlider'), value: DOM.get('fontSizeValue'), format: (v) => numFormat(Math.round(v)) },
                        { slider: DOM.get('opacitySlider'), value: DOM.get('opacityValue'), format: (v) => numFormat(v) + percentSymbol },
                        { slider: DOM.get('shadowSlider'), value: DOM.get('shadowValue'), format: (v) => numFormat(v) },
                        { slider: DOM.get('strokeSlider'), value: DOM.get('strokeValue'), format: (v) => numFormat(v) },
                        { slider: DOM.get('glowSlider'), value: DOM.get('glowValue'), format: (v) => numFormat(v) },
                        { slider: DOM.get('backdropOpacitySlider'), value: DOM.get('backdropOpacityValue'), format: (v) => numFormat(v) + percentSymbol },
                        { slider: DOM.get('backdropRadiusSlider'), value: DOM.get('backdropRadiusValue'), format: (v) => numFormat(v) },
                        { slider: DOM.get('backdropWidthSlider'), value: DOM.get('backdropWidthValue'), format: (v) => numFormat(v) },
                        { slider: DOM.get('backdropHeightSlider'), value: DOM.get('backdropHeightValue'), format: (v) => numFormat(v) }
                    ];

                    // ✅ FIXED: به‌روزرسانی فوری بدون requestAnimationFrame
                    updates.forEach(({ slider, value, format }) => {
                        if (slider && value) {
                            const formattedValue = format(slider.value);
                            value.textContent = formattedValue;
                        }
                    });
                } catch (error) {
                    memoryManager.logError('SLIDER_UPDATE_ERROR', error);
                }
            }

            showGuideLines(textBox) {
                try {
                    const canvas = DOM.get('canvas');
                    const verticalGuide = DOM.get('verticalGuide');
                    const horizontalGuide = DOM.get('horizontalGuide');
                    
                    if (!canvas || !verticalGuide || !horizontalGuide) return;
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const textCenterX = textBox.x + textBox.width / 2;
                    const textCenterY = textBox.y + textBox.height / 2;
                    
                    const threshold = 10;
                    
                    if (Math.abs(textCenterX - centerX) < threshold) {
                        verticalGuide.classList.add('active');
                        textBox.x = centerX - textBox.width / 2;
                    } else {
                        verticalGuide.classList.remove('active');
                    }
                    
                    if (Math.abs(textCenterY - centerY) < threshold) {
                        horizontalGuide.classList.add('active');
                        textBox.y = centerY - textBox.height / 2;
                    } else {
                        horizontalGuide.classList.remove('active');
                    }
                } catch (error) {
                    memoryManager.logError('GUIDE_LINES_ERROR', error);
                }
            }

            hideGuideLines() {
                try {
                    const verticalGuide = DOM.get('verticalGuide');
                    const horizontalGuide = DOM.get('horizontalGuide');
                    
                    if (verticalGuide) verticalGuide.classList.remove('active');
                    if (horizontalGuide) horizontalGuide.classList.remove('active');
                } catch (error) {
                    memoryManager.logError('HIDE_GUIDE_LINES_ERROR', error);
                }
            }
        }

        // Initialize UI manager
        const uiManager = new UIManager();

        // ✅ FIXED: Enhanced Text Manager with Lightning-Fast UI Sync
        class TextManager {
            constructor() {
                this.maxTextObjects = 3;
            }

            addFontPanel() {
                try {
                    if (appState.fontPanels.length >= this.maxTextObjects) {
                        showAlert(languageManager.translateText('maxPanels'));
                        return false;
                    }

                    const panelDiv = document.createElement('div');
                    panelDiv.className = 'font-panel';
                    panelDiv.setAttribute('role', 'group');
                    panelDiv.setAttribute('aria-label', `Text panel ${appState.fontPanels.length + 1}`);
                    
                    panelDiv.innerHTML = `
                        <textarea placeholder="${languageManager.translateText('textPlaceholder')}" class="font-text-input" rows="1" aria-label="Text input"></textarea>
                        <button class="remove-font" aria-label="Remove this text panel">×</button>
                    `;
                    
                    const textInput = panelDiv.querySelector('.font-text-input');
                    const removeBtn = panelDiv.querySelector('.remove-font');

                    this.setupTextInput(textInput, panelDiv);
                    this.setupRemoveButton(removeBtn, panelDiv);
                    this.setupPanelInteraction(panelDiv);

                    const fontPanelsContainer = DOM.get('fontPanelsContainer');
                    if (fontPanelsContainer) {
                        fontPanelsContainer.appendChild(panelDiv);
                    }
                    
                    appState.fontPanels.push(panelDiv);

                    const textObj = appState.createTextObject(
                        '', 
                        DOM.get('canvas').width / 2 - 100, 
                        (DOM.get('canvas').height / 2 - 30) + (appState.textObjects.length * 80)
                    );
                    appState.textObjects.push(textObj);

                    const addFontPanelBtn = DOM.get('addFontPanelBtn');
                    if (appState.fontPanels.length >= this.maxTextObjects && addFontPanelBtn) {
                        addFontPanelBtn.disabled = true;
                        addFontPanelBtn.setAttribute('aria-disabled', 'true');
                    }

                    this.selectTextObject(appState.textObjects.length - 1);
                    performanceMonitor.scheduleDraw(true);
                    
                    accessibilityManager.announce(`Text panel ${appState.fontPanels.length} added`);
                    return true;
                } catch (error) {
                    memoryManager.logError('ADD_FONT_PANEL_ERROR', error);
                    return false;
                }
            }

            // ✅ FIXED: Ultra-Fast Text Input with Instant Response
            setupTextInput(textInput, panelDiv) {
                const autoResizeTextarea = (textarea) => {
                    try {
                        const maxHeight = 60;
                        textarea.style.height = 'auto';
                        const newHeight = Math.min(textarea.scrollHeight, maxHeight);
                        textarea.style.height = newHeight + 'px';
                        
                        if (textarea.scrollHeight > maxHeight) {
                            textarea.classList.add('scrollable');
                        } else {
                            textarea.classList.remove('scrollable');
                        }
                    } catch (error) {
                        memoryManager.logError('TEXTAREA_RESIZE_ERROR', error);
                    }
                };

                // ✅ Use 'input' event for instant response
                memoryManager.addEventListener(textInput, 'input', (e) => {
                    try {
                        const panelIndex = appState.fontPanels.indexOf(panelDiv);
                        if (panelIndex >= 0 && appState.textObjects[panelIndex]) {
                            appState.textObjects[panelIndex].text = e.target.value;
                            // ✅ Immediate canvas update
                            performanceMonitor.scheduleDraw();
                        }
                        autoResizeTextarea(e.target);
                    } catch (error) {
                        memoryManager.logError('TEXT_INPUT_ERROR', error);
                    }
                });
                
                memoryManager.addEventListener(textInput, 'focus', () => {
                    try {
                        const panelIndex = appState.fontPanels.indexOf(panelDiv);
                        this.selectTextObject(panelIndex);
                    } catch (error) {
                        memoryManager.logError('TEXT_FOCUS_ERROR', error);
                    }
                });

                memoryManager.addEventListener(textInput, 'keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        setTimeout(() => autoResizeTextarea(e.target), 0);
                    }
                });

                autoResizeTextarea(textInput);
            }

            setupRemoveButton(removeBtn, panelDiv) {
                memoryManager.addEventListener(removeBtn, 'click', () => {
                    this.removeFontPanel(panelDiv);
                });

                memoryManager.addEventListener(removeBtn, 'keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.removeFontPanel(panelDiv);
                    }
                });
            }

            setupPanelInteraction(panelDiv) {
                memoryManager.addEventListener(panelDiv, 'click', (e) => {
                    if (e.detail !== 1) return;
                    const panelIndex = appState.fontPanels.indexOf(panelDiv);
                    this.selectTextObject(panelIndex);
                });

                memoryManager.addEventListener(panelDiv, 'dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const panelIndex = appState.fontPanels.indexOf(panelDiv);
                    this.selectTextObject(panelIndex);
                    
                    const textPanel = document.getElementById('textPanel');
                    if (textPanel && !textPanel.classList.contains('active')) {
                        uiManager.openPanel('text');
                    }
                });

                let panelLastTouchTime = 0;
                let panelTouchCount = 0;

                memoryManager.addEventListener(panelDiv, 'touchend', (e) => {
                    const now = Date.now();
                    if (now - panelLastTouchTime < 300) {
                        panelTouchCount++;
                        if (panelTouchCount === 2) {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const panelIndex = appState.fontPanels.indexOf(panelDiv);
                            this.selectTextObject(panelIndex);
                            
                            const textPanel = document.getElementById('textPanel');
                            if (textPanel && !textPanel.classList.contains('active')) {
                                uiManager.openPanel('text');
                            }
                            panelTouchCount = 0;
                        }
                    } else {
                        panelTouchCount = 1;
                    }
                    panelLastTouchTime = now;
                });
            }

            removeFontPanel(panelDiv) {
                try {
                    const index = appState.fontPanels.indexOf(panelDiv);
                    if (index > -1) {
                        appState.fontPanels.splice(index, 1);
                        appState.textObjects.splice(index, 1);
                        panelDiv.remove();
                        
                        const addFontPanelBtn = DOM.get('addFontPanelBtn');
                        if (addFontPanelBtn) {
                            addFontPanelBtn.disabled = appState.fontPanels.length >= this.maxTextObjects;
                            addFontPanelBtn.setAttribute('aria-disabled', addFontPanelBtn.disabled);
                        }
                        
                        // ✅ FIXED: Proper index adjustment after removal
                        if (appState.selectedTextIndex === index) {
                            appState.selectedTextIndex = Math.max(0, appState.fontPanels.length - 1);
                        } else if (appState.selectedTextIndex > index) {
                            appState.selectedTextIndex--;
                        }
                        
                        if (appState.textObjects.length === 0) {
                            appState.selectedTextIndex = -1;
                        } else if (appState.selectedTextIndex >= appState.textObjects.length) {
                            appState.selectedTextIndex = appState.textObjects.length - 1;
                        }
                        
                        this.updateUIFromSelectedText();
                        performanceMonitor.scheduleDraw(true);
                        
                        accessibilityManager.announce(`Text panel ${index + 1} removed`);
                    }
                } catch (error) {
                    memoryManager.logError('REMOVE_FONT_PANEL_ERROR', error);
                }
            }

            // ✅ FIXED: Lightning-Fast Text Selection with Instant UI Response
            selectTextObject(index) {
                try {
                    if (index >= 0 && index < appState.textObjects.length) {
                        // Clear previous selection state
                        if (appState.selectionBorderTimeout) {
                            clearTimeout(appState.selectionBorderTimeout);
                            appState.selectionBorderTimeout = null;
                        }
                        if (appState.borderFadeTimeout) {
                            clearTimeout(appState.borderFadeTimeout);
                            appState.borderFadeTimeout = null;
                        }
                        
                        // Update selection index
                        appState.selectedTextIndex = index;
                        
                        // ✅ FIXED: Ultra-Fast Panel Selection with Batch Updates
                        requestAnimationFrame(() => {
                            appState.fontPanels.forEach((panel, i) => {
                                const isSelected = i === index;
                                panel.classList.toggle('selected', isSelected);
                                panel.setAttribute('aria-selected', isSelected.toString());
                            });
                        });
                        
                        // ✅ FIXED: Instant UI Sync
                        this.updateUIFromSelectedText();
                        
                        // Schedule redraw
                        performanceMonitor.scheduleDraw(true);
                        
                        // Setup selection border timeout
                        appState.selectionBorderTimeout = setTimeout(() => {
                            appState.borderFadeTimeout = setTimeout(() => {
                                performanceMonitor.scheduleDraw();
                            }, 100);
                        }, 5000);
                        
                        accessibilityManager.announce(`Text object ${index + 1} selected`);
                        console.log(`✅ Text object ${index} selected successfully`);
                    } else {
                        console.warn(`⚠️ Invalid text object index: ${index}`);
                    }
                } catch (error) {
                    memoryManager.logError('SELECT_TEXT_ERROR', error);
                    console.error('❌ Error selecting text object:', error);
                }
            }

            // ✅ FIXED: Instant UI Updates with Performance Optimization
            updateUIFromSelectedText() {
                try {
                    if (appState.selectedTextIndex >= 0 && appState.selectedTextIndex < appState.textObjects.length) {
                        const textObj = appState.textObjects[appState.selectedTextIndex];
                        
                        // Ensure textObj exists
                        if (!textObj) {
                            console.warn('⚠️ Selected text object does not exist');
                            return;
                        }
                        
                        // ✅ FIXED: Batch UI Updates with requestAnimationFrame for ultra-fast response
                        requestAnimationFrame(() => {
                            const updates = [
                                { element: DOM.get('fontSizeSlider'), value: Math.round(textObj.fontSize) },
                                { element: DOM.get('opacitySlider'), value: Math.round(textObj.opacity * 100) },
                                { element: DOM.get('shadowSlider'), value: Math.round(textObj.shadowBlur) },
                                { element: DOM.get('strokeSlider'), value: Math.round(textObj.strokeWidth) },
                                { element: DOM.get('glowSlider'), value: Math.round(textObj.glowBlur) },
                                { element: DOM.get('backdropOpacitySlider'), value: Math.round(textObj.backdropOpacity * 100) },
                                { element: DOM.get('backdropRadiusSlider'), value: Math.round(textObj.backdropRadius) },
                                { element: DOM.get('backdropWidthSlider'), value: Math.round(textObj.backdropWidthPercentage) },
                                { element: DOM.get('backdropHeightSlider'), value: Math.round(textObj.backdropHeightPercentage) },
                                { element: DOM.get('fontSelector'), value: textObj.font }
                            ];

                            updates.forEach(({ element, value }) => {
                                if (element && element.value !== undefined) {
                                    // ✅ Only update if value changed to prevent unnecessary DOM manipulation
                                    if (element.value != value) {
                                        element.value = value;
                                    }
                                }
                            });
                            
                            // ✅ FIXED: Fast Color Grid Updates
                            this.updateColorGridSelection('textColorGrid', textObj.color);
                            this.updateColorGridSelection('bgColorGrid', textObj.backdropColor);
                            
                            // Update slider value displays immediately
                            uiManager.updateSliderValues();
                        });
                        
                        console.log(`✅ UI updated for text object ${appState.selectedTextIndex}`);
                    } else {
                        console.warn('⚠️ No valid text object selected for UI update');
                    }
                } catch (error) {
                    memoryManager.logError('UI_UPDATE_ERROR', error);
                    console.error('❌ Error updating UI from selected text:', error);
                }
            }

            updateColorGridSelection(gridId, color) {
                try {
                    const colorGrid = DOM.get(gridId);
                    if (!colorGrid) return;
                    
                    const hexColor = color.includes('rgb') ? this.rgbToHex(color) : color;
                    
                    colorGrid.querySelectorAll('.color-grid-swatch').forEach(swatch => {
                        const isActive = swatch.dataset.color.toLowerCase() === hexColor.toLowerCase();
                        swatch.classList.toggle('active', isActive);
                    });
                } catch (error) {
                    memoryManager.logError('COLOR_GRID_UPDATE_ERROR', error);
                }
            }

            rgbToHex(rgb) {
                try {
                    const result = rgb.match(/\d+/g);
                    if (result && result.length >= 3) {
                        return "#" + ((1 << 24) + (parseInt(result[0], 10) << 16) + (parseInt(result[1], 10) << 8) + parseInt(result[2], 10)).toString(16).slice(1);
                    }
                    return rgb;
                } catch (error) {
                    memoryManager.logError('RGB_TO_HEX_ERROR', error);
                    return rgb;
                }
            }
        }

        // Initialize text manager
        const textManager = new TextManager();

        // ✅ FIXED: Enhanced Interaction Manager with Proper Bounds
        class InteractionManager {
            constructor() {
                this.setupInteractionHandlers();
            }

            setupInteractionHandlers() {
                this.setupCanvasInteraction();
                this.setupCanvasTransform();
                this.setupDoubleTapDetection();
            }

            setupCanvasInteraction() {
                const canvas = DOM.get('canvas');
                if (!canvas) return;

                memoryManager.addEventListener(canvas, 'click', (e) => {
                    this.handleCanvasClick(e);
                });

                memoryManager.addEventListener(canvas, 'dblclick', (e) => {
                    this.handleCanvasDoubleClick(e);
                });

                memoryManager.addEventListener(canvas, 'touchend', (e) => {
                    this.handleCanvasTouchEnd(e);
                });
            }

            setupCanvasTransform() {
                const canvasWrapper = DOM.get('canvasWrapper');
                if (!canvasWrapper) return;

                memoryManager.addEventListener(canvasWrapper, 'mousedown', (e) => {
                    this.handleStart(e);
                });

                memoryManager.addEventListener(canvasWrapper, 'touchstart', (e) => {
                    this.handleStart(e);
                }, { passive: false });

                memoryManager.addEventListener(window, 'mousemove', (e) => {
                    this.handleMove(e);
                });

                memoryManager.addEventListener(window, 'touchmove', (e) => {
                    this.handleMove(e);
                }, { passive: false });

                memoryManager.addEventListener(window, 'mouseup', (e) => {
                    this.handleEnd(e);
                });

                memoryManager.addEventListener(window, 'touchend', (e) => {
                    this.handleEnd(e);
                });

                memoryManager.addEventListener(window, 'touchcancel', (e) => {
                    this.handleEnd(e);
                });
            }

            setupDoubleTapDetection() {
                const photoPlaceholder = DOM.get('photoPlaceholder');
                if (!photoPlaceholder) return;

                memoryManager.addEventListener(photoPlaceholder, 'touchend', (e) => {
                    this.handlePlaceholderDoubleTap(e);
                });

                memoryManager.addEventListener(photoPlaceholder, 'dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.showQuickActionModal();
                });
            }

            getPointerPos(e, el) {
                try {
                    const rect = el.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    return { x: clientX - rect.left, y: clientY - rect.top };
                } catch (error) {
                    memoryManager.logError('POINTER_POS_ERROR', error);
                    return { x: 0, y: 0 };
                }
            }
            
            getCanvasPos(e) {
                try {
                    const canvas = DOM.get('canvas');
                    if (!canvas) return { x: 0, y: 0 };
                    
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    return { 
                        x: (clientX - rect.left) * (canvas.width / rect.width), 
                        y: (clientY - rect.top) * (canvas.height / rect.height) 
                    };
                } catch (error) {
                    memoryManager.logError('CANVAS_POS_ERROR', error);
                    return { x: 0, y: 0 };
                }
            }

            handleStart(e) {
                try {
                    // Handle pinch zoom for text
                    if (e.touches && e.touches.length === 2) {
                        e.preventDefault();
                        appState.isPinching = true;
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        appState.initialPinchDistance = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                        if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                            appState.lastFontSize = appState.textObjects[appState.selectedTextIndex].fontSize;
                        }
                        return;
                    }

                    const canvasPos = this.getCanvasPos(e);
                    let clickedTextIndex = -1;
                    
                    // Check for text interaction first
                    for (let i = appState.textObjects.length - 1; i >= 0; i--) {
                        const textObj = appState.textObjects[i];
                        if (canvasPos.x >= textObj.x && canvasPos.x <= textObj.x + textObj.width &&
                            canvasPos.y >= textObj.y && canvasPos.y <= textObj.y + textObj.height) {
                            clickedTextIndex = i;
                            break;
                        }
                    }
                    
                    if (clickedTextIndex >= 0) {
                        // Text dragging
                        appState.isDraggingText = true;
                        appState.isDraggingCanvas = false;
                        appState.selectedTextIndex = clickedTextIndex;
                        textManager.selectTextObject(appState.selectedTextIndex);
                        appState.dragStart = {
                            x: canvasPos.x - appState.textObjects[appState.selectedTextIndex].x,
                            y: canvasPos.y - appState.textObjects[appState.selectedTextIndex].y
                        };
                        uiManager.showGuideLines(appState.textObjects[appState.selectedTextIndex]);
                    } else {
                        // Canvas dragging
                        appState.isDraggingCanvas = true;
                        appState.isDraggingText = false;
                        
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        
                        appState.lastPointer = { x: clientX, y: clientY };
                        appState.momentum = { x: 0, y: 0 };
                        
                        const canvasWrapper = DOM.get('canvasWrapper');
                        if (canvasWrapper) {
                            canvasWrapper.style.cursor = 'grabbing';
                            canvasWrapper.classList.remove('smooth-transition');
                        }
                        
                        e.preventDefault();
                    }
                } catch (error) {
                    memoryManager.logError('HANDLE_START_ERROR', error);
                }
            }

            handleMove(e) {
                try {
                    // Handle pinch zoom for text
                    if (e.touches && e.touches.length === 2 && appState.isPinching) {
                        e.preventDefault();
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        const currentDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                        const scale = currentDist / appState.initialPinchDistance;
                        
                        if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                            const newFontSize = Math.max(10, Math.min(200, appState.lastFontSize * scale));
                            appState.textObjects[appState.selectedTextIndex].fontSize = newFontSize;
                            
                            const fontSizeSlider = DOM.get('fontSizeSlider');
                            if (fontSizeSlider) fontSizeSlider.value = newFontSize;
                            
                            uiManager.updateSliderValues();
                            performanceMonitor.scheduleDraw();
                        }
                        return;
                    }

                    if (appState.isDraggingText && appState.selectedTextIndex >= 0) {
                        // Text movement
                        const canvasPos = this.getCanvasPos(e);
                        const textObj = appState.textObjects[appState.selectedTextIndex];
                        const canvas = DOM.get('canvas');
                        
                        const newX = Math.max(0, Math.min(canvasPos.x - appState.dragStart.x, canvas.width - textObj.width));
                        const newY = Math.max(0, Math.min(canvasPos.y - appState.dragStart.y, canvas.height - textObj.height));
                        
                        textObj.x = newX;
                        textObj.y = newY;
                        
                        uiManager.showGuideLines(textObj);
                        performanceMonitor.scheduleDraw();
                    } else if (appState.isDraggingCanvas) {
                        // Canvas movement
                        e.preventDefault();
                        
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        
                        const deltaX = clientX - appState.lastPointer.x;
                        const deltaY = clientY - appState.lastPointer.y;
                        
                        appState.momentum.x = deltaX * 0.8;
                        appState.momentum.y = deltaY * 0.8;
                        
                        const newX = appState.canvasTransform.x + deltaX;
                        const newY = appState.canvasTransform.y + deltaY;
                        
                        this.updateCanvasTransform(newX, newY, false);
                        
                        appState.lastPointer = { x: clientX, y: clientY };
                    }
                } catch (error) {
                    memoryManager.logError('HANDLE_MOVE_ERROR', error);
                }
            }

            handleEnd(e) {
                try {
                    if (e.touches && e.touches.length > 0) return;
                    
                    // Smooth canvas release with momentum
                    if (appState.isDraggingCanvas) {
                        const canvasWrapper = DOM.get('canvasWrapper');
                        if (canvasWrapper) {
                            canvasWrapper.style.cursor = 'grab';
                        }
                        
                        if (Math.abs(appState.momentum.x) > 2 || Math.abs(appState.momentum.y) > 2) {
                            const finalX = appState.canvasTransform.x + appState.momentum.x * 0.3;
                            const finalY = appState.canvasTransform.y + appState.momentum.y * 0.3;
                            this.updateCanvasTransform(finalX, finalY, true);
                        }
                    }

                    appState.isDraggingText = false;
                    appState.isDraggingCanvas = false;
                    appState.isPinching = false;
                    appState.momentum = { x: 0, y: 0 };

                    uiManager.hideGuideLines();
                } catch (error) {
                    memoryManager.logError('HANDLE_END_ERROR', error);
                }
            }

            // ✅ FIXED: Enhanced Canvas Position Constraints
            constrainCanvasPosition(x, y) {
                const bounds = appState.canvasBounds;
                
                // ✅ FIXED: Proper right constraint enforcement
                const constrainedX = Math.max(bounds.left, Math.min(bounds.right, x));
                const constrainedY = Math.max(bounds.top, Math.min(bounds.bottom, y));
                
                return { x: constrainedX, y: constrainedY };
            }

            updateCanvasTransform(x, y, smooth = false) {
                try {
                    const canvasWrapper = DOM.get('canvasWrapper');
                    if (!canvasWrapper) return;
                    
                    // ✅ FIXED: Enforced right boundary constraint
                    const constrained = this.constrainCanvasPosition(x, y);
                    
                    appState.canvasTransform.x = constrained.x;
                    appState.canvasTransform.y = constrained.y;
                    
                    if (smooth) {
                        canvasWrapper.classList.add('smooth-transition');
                        requestAnimationFrame(() => {
                            canvasWrapper.style.transform = `translate(${constrained.x}px, ${constrained.y}px)`;
                            setTimeout(() => {
                                canvasWrapper.classList.remove('smooth-transition');
                            }, 400);
                        });
                    } else {
                        canvasWrapper.style.transform = `translate(${constrained.x}px, ${constrained.y}px)`;
                    }
                    
                    console.log(`✅ Canvas position updated: x=${constrained.x}, y=${constrained.y}`);
                } catch (error) {
                    memoryManager.logError('TRANSFORM_ERROR', error);
                }
            }

            centerCanvas() {
                try {
                    const canvasWrapper = DOM.get('canvasWrapper');
                    if (!canvasWrapper) return;

                    appState.canvasTransform = { x: 0, y: 0 };
                    appState.momentum = { x: 0, y: 0 };

                    canvasWrapper.classList.add('smooth-transition');
                    canvasWrapper.style.transform = 'translate(0px, 0px)';

                    setTimeout(() => {
                        canvasWrapper.classList.remove('smooth-transition');
                    }, 400);
                    
                    accessibilityManager.announce('Canvas centered');
                } catch (error) {
                    memoryManager.logError('CENTER_CANVAS_ERROR', error);
                }
            }

            handleCanvasClick(e) {
                try {
                    if (!document.querySelector('.accordion-panel.active')) { 
                        uiManager.openPanel('text'); 
                    }
                    
                    const canvasPos = this.getCanvasPos(e);
                    let clickedTextIndex = -1;
                    
                    for (let i = appState.textObjects.length - 1; i >= 0; i--) {
                        const textObj = appState.textObjects[i];
                        if (canvasPos.x >= textObj.x && canvasPos.x <= textObj.x + textObj.width &&
                            canvasPos.y >= textObj.y && canvasPos.y <= textObj.y + textObj.height) {
                            clickedTextIndex = i;
                            break;
                        }
                    }
                     
                    if (clickedTextIndex >= 0) {
                        textManager.selectTextObject(clickedTextIndex);
                    }
                } catch (error) {
                    memoryManager.logError('CANVAS_CLICK_ERROR', error);
                }
            }

            handleCanvasDoubleClick(e) {
                try {
                    const canvasPos = this.getCanvasPos(e);
                    let clickedTextIndex = -1;
                    
                    for (let i = appState.textObjects.length - 1; i >= 0; i--) {
                        const textObj = appState.textObjects[i];
                        if (canvasPos.x >= textObj.x && canvasPos.x <= textObj.x + textObj.width &&
                            canvasPos.y >= textObj.y && canvasPos.y <= textObj.y + textObj.height) {
                            clickedTextIndex = i;
                            break;
                        }
                    }
                    
                    if (clickedTextIndex === -1) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.centerCanvas();
                    } else {
                        textManager.selectTextObject(clickedTextIndex);
                        const textPanel = document.getElementById('textPanel');
                        if (textPanel && !textPanel.classList.contains('active')) {
                            uiManager.openPanel('text');
                        }
                    }
                } catch (error) {
                    memoryManager.logError('CANVAS_DOUBLE_CLICK_ERROR', error);
                }
            }

            handleCanvasTouchEnd(e) {
                try {
                    const now = Date.now();
                    if (now - appState.lastCanvasTouchTime < 300) {
                        appState.canvasTouchCount++;
                        if (appState.canvasTouchCount === 2) {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const canvasPos = this.getCanvasPos(e.changedTouches[0]);
                            let clickedTextIndex = -1;
                            
                            for (let i = appState.textObjects.length - 1; i >= 0; i--) {
                                const textObj = appState.textObjects[i];
                                if (canvasPos.x >= textObj.x && canvasPos.x <= textObj.x + textObj.width &&
                                    canvasPos.y >= textObj.y && canvasPos.y <= textObj.y + textObj.height) {
                                    clickedTextIndex = i;
                                    break;
                                }
                            }
                            
                            if (clickedTextIndex === -1) {
                                this.centerCanvas();
                            } else {
                                textManager.selectTextObject(clickedTextIndex);
                                const textPanel = document.getElementById('textPanel');
                                if (textPanel && !textPanel.classList.contains('active')) {
                                    uiManager.openPanel('text');
                                }
                            }
                            appState.canvasTouchCount = 0;
                        }
                    } else {
                        appState.canvasTouchCount = 1;
                    }
                    appState.lastCanvasTouchTime = now;
                } catch (error) {
                    memoryManager.logError('CANVAS_TOUCH_ERROR', error);
                }
            }

            handlePlaceholderDoubleTap(e) {
                try {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const now = Date.now();
                    if (now - appState.lastTapTime < appState.doubleTapDelay) {
                        appState.tapCount++;
                        if (appState.tapCount === 2) {
                            this.showQuickActionModal();
                            appState.tapCount = 0;
                            return;
                        }
                    } else {
                        appState.tapCount = 1;
                    }
                    appState.lastTapTime = now;
                } catch (error) {
                    memoryManager.logError('PLACEHOLDER_TAP_ERROR', error);
                }
            }

            showQuickActionModal() {
                accessibilityManager.openModal('quickActionModal');
            }

            hideQuickActionModal() {
                accessibilityManager.closeModal('quickActionModal');
            }
        }

        // Initialize interaction manager
        const interactionManager = new InteractionManager();

        // ✅ FIXED: Enhanced Image Manager with Complete Error Handling
        class ImageManager {
            constructor() {
                this.maxFileSize = 50 * 1024 * 1024; // 50MB
                this.supportedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'];
            }

            validateImageFile(file) {
                if (!file) {
                    throw new Error('NO_FILE_PROVIDED');
                }

                if (!file.type || !this.supportedTypes.includes(file.type)) {
                    throw new Error('INVALID_FILE_TYPE');
                }

                if (file.size > this.maxFileSize) {
                    throw new Error('FILE_TOO_LARGE');
                }

                return true;
            }

            async initializeCropModal(imageFile) {
                try {
                    this.validateImageFile(imageFile);
                    
                    accessibilityManager.openModal('cropModal');
                    cropState.reset();
                    
                    const cropLoading = DOM.get('cropLoading');
                    const cropImage = DOM.get('cropImage');
                    
                    if (cropLoading) cropLoading.style.display = 'flex';
                    if (cropImage) cropImage.style.display = 'none';
                    
                    const imageUrl = memoryManager.createBlobUrl(imageFile);
                    if (!imageUrl) {
                        throw new Error('BLOB_URL_CREATION_FAILED');
                    }
                    
                    cropState.originalImage = new Image();
                    
                    await new Promise((resolve, reject) => {
                        cropState.originalImage.onload = () => {
                            try {
                                this.setupCrop();
                                if (cropLoading) cropLoading.style.display = 'none';
                                if (cropImage) cropImage.style.display = 'block';
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        
                        cropState.originalImage.onerror = () => {
                            reject(new Error('IMAGE_LOAD_FAILED'));
                        };
                        
                        // Set timeout for image loading
                        setTimeout(() => {
                            reject(new Error('IMAGE_LOAD_TIMEOUT'));
                        }, 30000);
                        
                        cropState.originalImage.src = imageUrl;
                    });
                    
                } catch (error) {
                    console.error('Image processing error:', error);
                    memoryManager.logError('CROP_INIT_ERROR', error);
                    
                    let errorMessage = languageManager.translateText('fileError');
                    
                    if (error.message === 'INVALID_FILE_TYPE') {
                        errorMessage = appState.currentLang === 'fa' ? 'فرمت فایل نامعتبر است' :
                                       appState.currentLang === 'ar' ? 'تنسيق الملف غير صالح' :
                                       'Invalid file format';
                    } else if (error.message === 'FILE_TOO_LARGE') {
                        errorMessage = appState.currentLang === 'fa' ? 'حجم فایل خیلی بزرگ است' :
                                       appState.currentLang === 'ar' ? 'حجم الملف كبير جداً' :
                                       'File size too large';
                    } else if (error.message === 'IMAGE_LOAD_TIMEOUT') {
                        errorMessage = appState.currentLang === 'fa' ? 'بارگذاری تصویر طولانی شد' :
                                       appState.currentLang === 'ar' ? 'استغرق تحميل الصورة وقتاً طويلاً' :
                                       'Image loading took too long';
                    }
                    
                    showAlert(errorMessage);
                    accessibilityManager.closeModal('cropModal');
                }
            }

            setupCrop() {
                const cropViewport = DOM.get('cropViewport');
                if (!cropViewport || !cropState.originalImage) return;
                
                const rect = cropViewport.getBoundingClientRect();
                const viewportWidth = rect.width;
                const viewportHeight = rect.height;
                
                const frameAspectRatio = 9/16;
                let frameWidth, frameHeight;
                
                frameHeight = Math.min(viewportHeight * 0.8, window.innerHeight * 0.6);
                frameWidth = frameHeight * frameAspectRatio;
                
                if (frameWidth > viewportWidth * 0.8) {
                    frameWidth = viewportWidth * 0.8;
                    frameHeight = frameWidth / frameAspectRatio;
                }
                
                const frameLeft = (viewportWidth - frameWidth) / 2;
                const frameTop = (viewportHeight - frameHeight) / 2;
                
                const cropFrame = DOM.get('cropFrame');
                if (cropFrame) {
                    cropFrame.style.left = frameLeft + 'px';
                    cropFrame.style.top = frameTop + 'px';
                    cropFrame.style.width = frameWidth + 'px';
                    cropFrame.style.height = frameHeight + 'px';
                }
                
                cropState.bounds = { 
                    left: frameLeft, 
                    top: frameTop, 
                    right: frameLeft + frameWidth, 
                    bottom: frameTop + frameHeight 
                };
                
                const imageAspect = cropState.originalImage.naturalWidth / cropState.originalImage.naturalHeight;
                const frameAspect = frameWidth / frameHeight;
                
                if (imageAspect > frameAspect) {
                    cropState.scale = frameHeight / cropState.originalImage.naturalHeight;
                } else {
                    cropState.scale = frameWidth / cropState.originalImage.naturalWidth;
                }
                
                cropState.initialScale = cropState.scale;
                cropState.minScale = cropState.scale;
                cropState.position = { x: 0, y: 0 };
                
                this.updateCropImageDisplay();
            }

            updateCropImageDisplay() {
                if (!cropState.originalImage || !DOM.get('cropViewport') || !DOM.get('cropImage')) return;
                
                const rect = DOM.get('cropViewport').getBoundingClientRect();
                const viewportWidth = rect.width;
                const viewportHeight = rect.height;
                
                const displayWidth = cropState.originalImage.naturalWidth * cropState.scale;
                const displayHeight = cropState.originalImage.naturalHeight * cropState.scale;
                
                const imageLeft = (viewportWidth - displayWidth) / 2 + cropState.position.x;
                const imageTop = (viewportHeight - displayHeight) / 2 + cropState.position.y;
                
                const cropImage = DOM.get('cropImage');
                cropImage.src = cropState.originalImage.src;
                cropImage.style.width = displayWidth + 'px';
                cropImage.style.height = displayHeight + 'px';
                cropImage.style.left = imageLeft + 'px';
                cropImage.style.top = imageTop + 'px';
                
                const zoomInfo = DOM.get('zoomInfo');
                if (zoomInfo) {
                    const zoomPercentage = Math.round((cropState.scale / cropState.initialScale) * 100);
                    zoomInfo.textContent = zoomPercentage + '%';
                }
            }

            constrainCropPosition() {
                if (!cropState.originalImage) return;
                
                const rect = DOM.get('cropViewport').getBoundingClientRect();
                const displayWidth = cropState.originalImage.naturalWidth * cropState.scale;
                const displayHeight = cropState.originalImage.naturalHeight * cropState.scale;
                
                const frameWidth = cropState.bounds.right - cropState.bounds.left;
                const frameHeight = cropState.bounds.bottom - cropState.bounds.top;
                
                const maxOffsetX = Math.max(0, (displayWidth - frameWidth) / 2);
                const maxOffsetY = Math.max(0, (displayHeight - frameHeight) / 2);
                
                cropState.position.x = Math.max(-maxOffsetX, Math.min(maxOffsetX, cropState.position.x));
                cropState.position.y = Math.max(-maxOffsetY, Math.min(maxOffsetY, cropState.position.y));
            }

            async applyCrop() {
                try {
                    if (!cropState.originalImage || !DOM.get('cropViewport')) return;
                    
                    const rect = DOM.get('cropViewport').getBoundingClientRect();
                    const viewportWidth = rect.width;
                    const viewportHeight = rect.height;
                    
                    const displayWidth = cropState.originalImage.naturalWidth * cropState.scale;
                    const displayHeight = cropState.originalImage.naturalHeight * cropState.scale;
                    
                    const imageLeft = (viewportWidth - displayWidth) / 2 + cropState.position.x;
                    const imageTop = (viewportHeight - displayHeight) / 2 + cropState.position.y;
                    
                    const frameLeft = cropState.bounds.left;
                    const frameTop = cropState.bounds.top;
                    const frameWidth = cropState.bounds.right - cropState.bounds.left;
                    const frameHeight = cropState.bounds.bottom - cropState.bounds.top;
                    
                    const sourceX = Math.max(0, (frameLeft - imageLeft) / cropState.scale);
                    const sourceY = Math.max(0, (frameTop - imageTop) / cropState.scale);
                    const sourceWidth = Math.min(
                        cropState.originalImage.naturalWidth - sourceX, 
                        frameWidth / cropState.scale
                    );
                    const sourceHeight = Math.min(
                        cropState.originalImage.naturalHeight - sourceY, 
                        frameHeight / cropState.scale
                    );
                    
                    const finalCanvas = document.createElement('canvas');
                    const finalCtx = finalCanvas.getContext('2d');
                    
                    if (!finalCtx) {
                        throw new Error('CANVAS_CONTEXT_ERROR');
                    }
                    
                    const minResolution = 2048;
                    const scale = Math.max(1, minResolution / Math.max(frameWidth, frameHeight));
                    
                    finalCanvas.width = Math.round(frameWidth * scale);
                    finalCanvas.height = Math.round(frameHeight * scale);
                    
                    // Check memory constraints
                    const pixels = finalCanvas.width * finalCanvas.height;
                    if (pixels > 16777216) { // 4096x4096 max
                        throw new Error('MEMORY_ERROR');
                    }
                    
                    finalCtx.imageSmoothingEnabled = true;
                    finalCtx.imageSmoothingQuality = 'high';
                    
                    finalCtx.drawImage(
                        cropState.originalImage,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        0, 0, finalCanvas.width, finalCanvas.height
                    );
                    
                    const blob = await new Promise((resolve, reject) => {
                        finalCanvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('BLOB_GENERATION_FAILED'));
                            }
                        }, 'image/png');
                    });
                    
                    const url = memoryManager.createBlobUrl(blob);
                    if (!url) {
                        throw new Error('BLOB_URL_CREATION_FAILED');
                    }
                    
                    appState.img = new Image();
                    
                    await new Promise((resolve, reject) => {
                        appState.img.onload = () => {
                            memoryManager.revokeBlobUrl(url);
                            this.loadImageToCanvas();
                            accessibilityManager.closeModal('cropModal');
                            
                            cropState.reset();
                            
                            setTimeout(() => {
                                canvasRenderer.updateCanvasBounds();
                                performanceMonitor.scheduleDraw(true);
                            }, 100);
                            
                            resolve();
                        };
                        
                        appState.img.onerror = () => {
                            memoryManager.revokeBlobUrl(url);
                            reject(new Error('PROCESSED_IMAGE_LOAD_FAILED'));
                        };
                        
                        appState.img.src = url;
                    });
                    
                } catch (error) {
                    console.error('Error applying crop:', error);
                    memoryManager.logError('CROP_APPLY_ERROR', error);
                    showAlert(languageManager.translateText('fileError'));
                }
            }

            loadImageToCanvas() {
                try {
                    if (!appState.img || !DOM.get('canvas') || !canvasRenderer.ctx) return;
                    
                    const originalWidth = appState.img.naturalWidth || appState.img.width;
                    const originalHeight = appState.img.naturalHeight || appState.img.height;
                    
                    if (!originalWidth || !originalHeight) {
                        throw new Error('INVALID_IMAGE_DIMENSIONS');
                    }
                    
                    const targetAspectRatio = 9/16;
                    let canvasWidth, canvasHeight;
                    
                    if (originalWidth / originalHeight > targetAspectRatio) {
                        canvasHeight = originalHeight;
                        canvasWidth = Math.round(canvasHeight * targetAspectRatio);
                    } else {
                        canvasWidth = originalWidth;
                        canvasHeight = Math.round(canvasWidth / targetAspectRatio);
                    }
                    
                    const minResolution = 2048;
                    if (Math.max(canvasWidth, canvasHeight) < minResolution) {
                        const scale = minResolution / Math.max(canvasWidth, canvasHeight);
                        canvasWidth = Math.round(canvasWidth * scale);
                        canvasHeight = Math.round(canvasHeight * scale);
                    }
                    
                    const maxResolution = 4096;
                    if (Math.max(canvasWidth, canvasHeight) > maxResolution) {
                        const scale = maxResolution / Math.max(canvasWidth, canvasHeight);
                        canvasWidth = Math.round(canvasWidth * scale);
                        canvasHeight = Math.round(canvasHeight * scale);
                    }
                    
                    DOM.get('canvas').width = canvasWidth;
                    DOM.get('canvas').height = canvasHeight;
                    
                    appState.resetImageState();
                    
                    const deleteImageBtn = DOM.get('deleteImageBtn');
                    const photoPlaceholder = DOM.get('photoPlaceholder');
                    
                    if (deleteImageBtn) deleteImageBtn.style.display = 'flex';
                    if (photoPlaceholder) photoPlaceholder.style.display = 'none';
                    
                    canvasRenderer.updateCanvasBounds();
                    performanceMonitor.scheduleDraw(true);
                    
                    accessibilityManager.announce('Image loaded successfully');
                    
                } catch (error) {
                    console.error('Error loading image to canvas:', error);
                    memoryManager.logError('IMAGE_LOAD_ERROR', error);
                    showAlert(languageManager.translateText('fileError'));
                }
            }

            deleteImage() {
                try {
                    appState.img = null;
                    appState.originalImageData = null;
                    
                    const deleteImageBtn = DOM.get('deleteImageBtn');
                    const photoPlaceholder = DOM.get('photoPlaceholder');
                    const imageInput = DOM.get('imageInput');
                    
                    if (deleteImageBtn) deleteImageBtn.style.display = 'none';
                    if (photoPlaceholder) photoPlaceholder.style.display = 'flex';
                    if (imageInput) imageInput.value = '';
                    
                    performanceMonitor.scheduleDraw(true);
                    accessibilityManager.announce('Image deleted');
                } catch (error) {
                    memoryManager.logError('DELETE_IMAGE_ERROR', error);
                }
            }
        }

        // Initialize image manager
        const imageManager = new ImageManager();

        // ✅ FIXED: Enhanced Crop Interaction Manager
        class CropInteractionManager {
            constructor() {
                this.setupCropEventListeners();
            }

            setupCropEventListeners() {
                const cropViewport = DOM.get('cropViewport');
                if (cropViewport) {
                    memoryManager.addEventListener(cropViewport, 'mousedown', (e) => this.handleCropStart(e));
                    memoryManager.addEventListener(cropViewport, 'mousemove', (e) => this.handleCropMove(e));
                    memoryManager.addEventListener(cropViewport, 'mouseup', (e) => this.handleCropEnd(e));
                    memoryManager.addEventListener(cropViewport, 'wheel', (e) => this.handleCropWheel(e));
                    memoryManager.addEventListener(cropViewport, 'touchstart', (e) => this.handleCropStart(e), { passive: false });
                    memoryManager.addEventListener(cropViewport, 'touchmove', (e) => this.handleCropMove(e), { passive: false });
                    memoryManager.addEventListener(cropViewport, 'touchend', (e) => this.handleCropEnd(e));
                }

                const zoomIn = DOM.get('zoomIn');
                const zoomOut = DOM.get('zoomOut');
                
                if (zoomIn) {
                    memoryManager.addEventListener(zoomIn, 'click', () => this.zoomIn());
                    memoryManager.addEventListener(zoomIn, 'touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.zoomIn();
                    }, { passive: false });
                }

                if (zoomOut) {
                    memoryManager.addEventListener(zoomOut, 'click', () => this.zoomOut());
                    memoryManager.addEventListener(zoomOut, 'touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.zoomOut();
                    }, { passive: false });
                }

                const cropCancel = DOM.get('cropCancel');
                const cropConfirm = DOM.get('cropConfirm');

                if (cropCancel) {
                    memoryManager.addEventListener(cropCancel, 'click', () => this.cancelCrop());
                }

                if (cropConfirm) {
                    memoryManager.addEventListener(cropConfirm, 'click', () => this.confirmCrop());
                }
            }

            handleCropStart(e) {
                if (e.touches && e.touches.length === 2) {
                    cropState.isPinching = true;
                    cropState.isDragging = false;
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    cropState.initialDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    cropState.initialScale = cropState.scale;
                } else {
                    cropState.isDragging = true;
                    cropState.isPinching = false;
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    cropState.lastTouchPos = { x: clientX, y: clientY };
                }
                
                e.preventDefault();
            }

            handleCropMove(e) {
                e.preventDefault();
                
                if (cropState.isPinching && e.touches && e.touches.length === 2) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    
                    const scaleFactor = currentDistance / cropState.initialDistance;
                    cropState.scale = Math.max(
                        cropState.minScale, 
                        Math.min(cropState.maxScale, cropState.initialScale * scaleFactor)
                    );
                    
                    imageManager.constrainCropPosition();
                    imageManager.updateCropImageDisplay();
                } else if (cropState.isDragging) {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    const deltaX = clientX - cropState.lastTouchPos.x;
                    const deltaY = clientY - cropState.lastTouchPos.y;
                    
                    cropState.position.x += deltaX;
                    cropState.position.y += deltaY;
                    
                    imageManager.constrainCropPosition();
                    imageManager.updateCropImageDisplay();
                    
                    cropState.lastTouchPos = { x: clientX, y: clientY };
                }
            }

            handleCropEnd(e) {
                if (e.touches && e.touches.length > 0) return;
                
                cropState.isDragging = false;
                cropState.isPinching = false;
            }

            handleCropWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                cropState.scale = Math.max(
                    cropState.minScale, 
                    Math.min(cropState.maxScale, cropState.scale * delta)
                );
                imageManager.constrainCropPosition();
                imageManager.updateCropImageDisplay();
            }

            zoomIn() {
                cropState.scale = Math.min(cropState.maxScale, cropState.scale * 1.2);
                imageManager.constrainCropPosition();
                imageManager.updateCropImageDisplay();
                accessibilityManager.announce('Zoomed in');
            }

            zoomOut() {
                cropState.scale = Math.max(cropState.minScale, cropState.scale / 1.2);
                imageManager.constrainCropPosition();
                imageManager.updateCropImageDisplay();
                accessibilityManager.announce('Zoomed out');
            }

            cancelCrop() {
                accessibilityManager.closeModal('cropModal');
                cropState.reset();
                accessibilityManager.announce('Crop cancelled');
            }

            async confirmCrop() {
                try {
                    await imageManager.applyCrop();
                    accessibilityManager.announce('Crop applied successfully');
                } catch (error) {
                    memoryManager.logError('CROP_CONFIRM_ERROR', error);
                    showAlert(languageManager.translateText('fileError'));
                }
            }
        }

        // Initialize crop interaction manager
        const cropInteractionManager = new CropInteractionManager();

        // ✅ FIXED: Enhanced Export Manager with Complete JPEG Fix
        class ExportManager {
            constructor() {
                this.exportCanvas = document.createElement('canvas');
                this.exportCtx = this.exportCanvas.getContext('2d');
                this.isExporting = false;
            }

            // ✅ FIXED: High-Quality Full Export with Proper JPEG Parameters
            async exportHighQuality() {
                try {
                    if (this.isExporting) return;
                    this.isExporting = true;
                    
                    if (!appState.img && appState.textObjects.every(t => !t.text.trim())) {
                        showAlert(languageManager.translateText('alertImage'));
                        this.isExporting = false;
                        return;
                    }
                    
                    const sourceCanvas = DOM.get('canvas');
                    if (!sourceCanvas) {
                        throw new Error('CANVAS_NOT_FOUND');
                    }
                    
                    // ✅ FIXED: Enhanced Quality Export
                    const exportScale = 2; // Higher resolution
                    this.exportCanvas.width = sourceCanvas.width * exportScale;
                    this.exportCanvas.height = sourceCanvas.height * exportScale;
                    
                    this.exportCtx.clearRect(0, 0, this.exportCanvas.width, this.exportCanvas.height);
                    this.exportCtx.scale(exportScale, exportScale);
                    
                    // Draw background
                    if (appState.img) {
                        this.exportCtx.imageSmoothingEnabled = true;
                        this.exportCtx.imageSmoothingQuality = 'high';
                        this.exportCtx.drawImage(appState.img, 0, 0, sourceCanvas.width, sourceCanvas.height);
                    } else {
                        this.exportCtx.fillStyle = "#FFFFFF";
                        this.exportCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height);
                    }
                    
                    // Draw text objects with high quality
                    this.drawTextObjectsForExport(sourceCanvas.width, sourceCanvas.height);
                    
                    // ✅ FIXED: Proper JPEG Export with White Background
                    const blob = await new Promise((resolve, reject) => {
                        this.exportCanvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('EXPORT_FAILED'));
                            }
                        }, 'image/jpeg', 0.95); // High quality JPEG
                    });
                    
                    this.downloadBlob(blob, 'DACO-Story-HD.jpg');
                    showAlert(languageManager.translateText('saveSuccess'));
                    
                } catch (error) {
                    console.error('Export error:', error);
                    memoryManager.logError('EXPORT_ERROR', error);
                    showAlert(languageManager.translateText('saveError'));
                } finally {
                    this.isExporting = false;
                }
            }

            // ✅ FIXED: Text-Only PNG Export with Transparency
            async exportTextOnly() {
                try {
                    if (this.isExporting) return;
                    this.isExporting = true;
                    
                    if (appState.textObjects.every(t => !t.text.trim())) {
                        showAlert(languageManager.translateText('alertText'));
                        this.isExporting = false;
                        return;
                    }
                    
                    const sourceCanvas = DOM.get('canvas');
                    if (!sourceCanvas) {
                        throw new Error('CANVAS_NOT_FOUND');
                    }
                    
                    const exportScale = 2;
                    this.exportCanvas.width = sourceCanvas.width * exportScale;
                    this.exportCanvas.height = sourceCanvas.height * exportScale;
                    
                    this.exportCtx.clearRect(0, 0, this.exportCanvas.width, this.exportCanvas.height);
                    this.exportCtx.scale(exportScale, exportScale);
                    
                    // Draw only text objects (transparent background)
                    this.drawTextObjectsForExport(sourceCanvas.width, sourceCanvas.height);
                    
                    const blob = await new Promise((resolve, reject) => {
                        this.exportCanvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('EXPORT_FAILED'));
                            }
                        }, 'image/png');
                    });
                    
                    this.downloadBlob(blob, 'DACO-Text-Transparent.png');
                    showAlert(languageManager.translateText('downloadSuccess'));
                    
                } catch (error) {
                    console.error('Text export error:', error);
                    memoryManager.logError('TEXT_EXPORT_ERROR', error);
                    showAlert(languageManager.translateText('downloadError'));
                } finally {
                    this.isExporting = false;
                }
            }

            drawTextObjectsForExport(canvasWidth, canvasHeight) {
                try {
                    appState.textObjects.forEach(textObj => {
                        if (!textObj.text.trim()) return;
                        
                        const textLines = textObj.text.split('\n');
                        const isRTLText = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F]/.test(textObj.text);
                        
                        let baseFontSize = textObj.fontSize;
                        let calculatedFontSize = Math.max(16, (baseFontSize / 100) * Math.min(canvasWidth, canvasHeight) * 0.12);
                        
                        this.exportCtx.font = `${calculatedFontSize}px ${textObj.font}`;
                        
                        // Auto-adjust font size if text is too wide
                        let maxTextWidth = 0;
                        textLines.forEach(line => {
                            const metrics = this.exportCtx.measureText(line);
                            maxTextWidth = Math.max(maxTextWidth, metrics.width);
                        });
                        
                        if (maxTextWidth > canvasWidth * 0.95) {
                            calculatedFontSize *= (canvasWidth * 0.95) / maxTextWidth;
                            calculatedFontSize = Math.max(12, calculatedFontSize);
                        }
                        
                        this.exportCtx.font = `${calculatedFontSize}px ${textObj.font}`;
                        
                        const lineHeight = calculatedFontSize * 1.3;
                        const backdropPaddingX = (textObj.backdropWidthPercentage / 100) * maxTextWidth;
                        const backdropPaddingY = (textObj.backdropHeightPercentage / 100) * (lineHeight * textLines.length);
                        
                        const finalWidth = maxTextWidth + backdropPaddingX;
                        const finalHeight = (lineHeight * textLines.length) + backdropPaddingY;
                        
                        // Draw backdrop if needed
                        if (textObj.backdropOpacity > 0) {
                            this.exportCtx.fillStyle = textObj.backdropColor;
                            this.exportCtx.globalAlpha = textObj.backdropOpacity;
                            
                            const radius = Math.max(0, (textObj.backdropRadius / 100) * Math.min(finalWidth, finalHeight) / 2);
                            
                            if (radius > 0) {
                                this.exportCtx.beginPath();
                                this.exportCtx.moveTo(textObj.x + radius, textObj.y);
                                this.exportCtx.arcTo(textObj.x + finalWidth, textObj.y, textObj.x + finalWidth, textObj.y + finalHeight, radius);
                                this.exportCtx.arcTo(textObj.x + finalWidth, textObj.y + finalHeight, textObj.x, textObj.y + finalHeight, radius);
                                this.exportCtx.arcTo(textObj.x, textObj.y + finalHeight, textObj.x, textObj.y, radius);
                                this.exportCtx.arcTo(textObj.x, textObj.y, textObj.x + finalWidth, textObj.y, radius);
                                this.exportCtx.closePath();
                                this.exportCtx.fill();
                            } else {
                                this.exportCtx.fillRect(textObj.x, textObj.y, finalWidth, finalHeight);
                            }
                            
                            this.exportCtx.globalAlpha = 1;
                        }
                        
                        // Draw text
                        this.exportCtx.font = `${calculatedFontSize}px ${textObj.font}`;
                        this.exportCtx.textAlign = "center";
                        this.exportCtx.textBaseline = "middle";
                        
                        this.exportCtx.shadowColor = `rgba(0,0,0,0.5)`;
                        this.exportCtx.shadowBlur = Math.max(0, textObj.shadowBlur * (calculatedFontSize / 50));
                        this.exportCtx.strokeStyle = `rgb(0,0,0)`;
                        this.exportCtx.lineWidth = Math.max(0, textObj.strokeWidth * (calculatedFontSize / 50));
                        this.exportCtx.lineJoin = 'round';
                        this.exportCtx.lineCap = 'round';
                        
                        let lineY = textObj.y + (finalHeight / 2) - (((textLines.length - 1) * lineHeight) / 2);
                        
                        textLines.forEach(line => {
                            const x = textObj.x + finalWidth / 2;
                            
                            if (textObj.strokeWidth > 0) {
                                this.exportCtx.strokeText(line, x, lineY);
                            }
                            
                            if (textObj.glowBlur > 0) {
                                this.exportCtx.shadowColor = textObj.color;
                                this.exportCtx.shadowBlur = Math.max(0, textObj.glowBlur * (calculatedFontSize / 50));
                            }
                            
                            this.exportCtx.fillStyle = textObj.color;
                            this.exportCtx.globalAlpha = Math.max(0, Math.min(1, textObj.opacity));
                            
                            if (isRTLText || /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F]/.test(line)) {
                                this.exportCtx.direction = 'rtl';
                            } else {
                                this.exportCtx.direction = 'ltr';
                            }
                            
                            this.exportCtx.fillText(line, x, lineY);
                            
                            this.exportCtx.shadowBlur = Math.max(0, textObj.shadowBlur * (calculatedFontSize / 50));
                            this.exportCtx.shadowColor = `rgba(0,0,0,0.5)`;
                            
                            lineY += lineHeight;
                        });
                    });
                    
                    this.exportCtx.globalAlpha = 1;
                    this.exportCtx.shadowBlur = 0;
                } catch (error) {
                    memoryManager.logError('TEXT_DRAW_EXPORT_ERROR', error);
                }
            }

            downloadBlob(blob, filename) {
                try {
                    const url = memoryManager.createBlobUrl(blob);
                    if (!url) {
                        throw new Error('BLOB_URL_CREATION_FAILED');
                    }
                    
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.style.display = 'none';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    setTimeout(() => {
                        memoryManager.revokeBlobUrl(url);
                    }, 1000);
                    
                } catch (error) {
                    memoryManager.logError('DOWNLOAD_ERROR', error);
                    throw error;
                }
            }
        }

        // Initialize export manager
        const exportManager = new ExportManager();

        // ✅ FIXED: Enhanced Event Listeners Manager
        class EventListenersManager {
            constructor() {
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.setupHeaderButtons();
                this.setupControlPanels();
                this.setupSliderControls();
                this.setupColorGrids();
                this.setupFontControls();
                this.setupModalControls();
                this.setupThemeAndLanguage();
                this.setupImageHandling();
                this.setupDownloadHandling();
            }

            setupHeaderButtons() {
                const uploadImageBtn = DOM.get('uploadImageBtn');
                if (uploadImageBtn) {
                    memoryManager.addEventListener(uploadImageBtn, 'click', () => {
                        const imageInput = DOM.get('imageInput');
                        if (imageInput) imageInput.click();
                    });
                }

                const deleteImageBtn = DOM.get('deleteImageBtn');
                if (deleteImageBtn) {
                    memoryManager.addEventListener(deleteImageBtn, 'click', () => {
                        imageManager.deleteImage();
                    });
                }

                const downloadHeaderBtn = DOM.get('downloadHeaderBtn');
                if (downloadHeaderBtn) {
                    memoryManager.addEventListener(downloadHeaderBtn, 'click', () => {
                        accessibilityManager.openModal('downloadModal');
                    });
                }
            }

            setupControlPanels() {
                const controlIcons = DOM.get('controlIcons');
                if (controlIcons && controlIcons.length > 0) {
                    controlIcons.forEach(icon => {
                        memoryManager.addEventListener(icon, 'click', (e) => {
                            const panelType = e.currentTarget.dataset.panel;
                            if (panelType) {
                                uiManager.openPanel(panelType);
                            }
                        });
                        
                        memoryManager.addEventListener(icon, 'keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                e.currentTarget.click();
                            }
                        });
                    });
                }

                const closePanelBtns = DOM.get('closePanelBtns');
                if (closePanelBtns && closePanelBtns.length > 0) {
                    closePanelBtns.forEach(btn => {
                        memoryManager.addEventListener(btn, 'click', (e) => {
                            const panelType = e.currentTarget.dataset.close;
                            if (panelType) {
                                uiManager.closePanel(panelType);
                            }
                        });
                    });
                }
            }

            // ✅ FIXED: Ultra-Fast Slider Response System - ENHANCED VERSION
            setupSliderControls() {
                // ✅ FIXED: Ultra-Fast Slider Response
                const setupSlider = (sliderId, updateFn) => {
                    const slider = DOM.get(sliderId);
                    if (!slider) return;

                    const handleUpdate = (e) => {
                        if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                            updateFn(e.target.value);
                            performanceMonitor.scheduleDraw();
                            uiManager.updateSliderValues();
                        }
                    };

                    // ✅ استفاده از هر دو input و change برای پاسخ فوری
                    memoryManager.addEventListener(slider, 'input', handleUpdate);
                    memoryManager.addEventListener(slider, 'change', handleUpdate);
                };

                // Font size slider
                setupSlider('fontSizeSlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].fontSize = parseInt(value);
                });

                // Opacity slider
                setupSlider('opacitySlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].opacity = value / 100;
                });

                // Shadow slider
                setupSlider('shadowSlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].shadowBlur = parseInt(value);
                });

                // Stroke slider
                setupSlider('strokeSlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].strokeWidth = parseInt(value);
                });

                // Glow slider
                setupSlider('glowSlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].glowBlur = parseInt(value);
                });

                // Backdrop opacity slider
                setupSlider('backdropOpacitySlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].backdropOpacity = value / 100;
                });

                // Backdrop radius slider
                setupSlider('backdropRadiusSlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].backdropRadius = parseInt(value);
                });

                // Backdrop width slider
                setupSlider('backdropWidthSlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].backdropWidthPercentage = parseInt(value);
                });

                // Backdrop height slider
                setupSlider('backdropHeightSlider', (value) => {
                    appState.textObjects[appState.selectedTextIndex].backdropHeightPercentage = parseInt(value);
                });
            }

            setupColorGrids() {
                const textColorGrid = DOM.get('textColorGrid');
                if (textColorGrid) {
                    uiManager.createColorGrid(textColorGrid, (color) => {
                        if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                            appState.textObjects[appState.selectedTextIndex].color = color;
                            performanceMonitor.scheduleDraw();
                        }
                    });
                }

                const bgColorGrid = DOM.get('bgColorGrid');
                if (bgColorGrid) {
                    uiManager.createColorGrid(bgColorGrid, (color) => {
                        if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                            appState.textObjects[appState.selectedTextIndex].backdropColor = color;
                            performanceMonitor.scheduleDraw();
                        }
                    });
                }
            }

            setupFontControls() {
                const fontSelector = DOM.get('fontSelector');
                if (fontSelector) {
                    memoryManager.addEventListener(fontSelector, 'change', (e) => {
                        appState.currentFont = e.target.value;
                        if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                            appState.textObjects[appState.selectedTextIndex].font = e.target.value;
                            performanceMonitor.scheduleDraw();
                        }
                    });
                }

                const fontInput = DOM.get('fontInput');
                if (fontInput) {
                    memoryManager.addEventListener(fontInput, 'change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            const fileName = file.name.replace(/\.[^/.]+$/, "");
                            await fontManager.loadCustomFont(file, fileName);
                            e.target.value = '';
                        }
                    });
                }

                const addFontPanelBtn = DOM.get('addFontPanelBtn');
                if (addFontPanelBtn) {
                    memoryManager.addEventListener(addFontPanelBtn, 'click', () => {
                        textManager.addFontPanel();
                    });
                }
            }

            setupModalControls() {
                // Quick action modal
                const quickAddImage = DOM.get('quickAddImage');
                if (quickAddImage) {
                    memoryManager.addEventListener(quickAddImage, 'click', () => {
                        interactionManager.hideQuickActionModal();
                        const imageInput = DOM.get('imageInput');
                        if (imageInput) imageInput.click();
                    });
                }

                const quickAddText = DOM.get('quickAddText');
                if (quickAddText) {
                    memoryManager.addEventListener(quickAddText, 'click', () => {
                        interactionManager.hideQuickActionModal();
                        textManager.addFontPanel();
                        uiManager.openPanel('text');
                    });
                }

                // Download modal
                const saveToGalleryCard = DOM.get('saveToGalleryCard');
                if (saveToGalleryCard) {
                    memoryManager.addEventListener(saveToGalleryCard, 'click', () => {
                        accessibilityManager.closeModal('downloadModal');
                        exportManager.exportHighQuality();
                    });
                }

                const downloadTransparentCard = DOM.get('downloadTransparentCard');
                if (downloadTransparentCard) {
                    memoryManager.addEventListener(downloadTransparentCard, 'click', () => {
                        accessibilityManager.closeModal('downloadModal');
                        exportManager.exportTextOnly();
                    });
                }

                const closeDownloadModal = DOM.get('closeDownloadModal');
                if (closeDownloadModal) {
                    memoryManager.addEventListener(closeDownloadModal, 'click', () => {
                        accessibilityManager.closeModal('downloadModal');
                    });
                }
            }

            setupThemeAndLanguage() {
                const themeToggle = DOM.get('themeToggle');
                if (themeToggle) {
                    memoryManager.addEventListener(themeToggle, 'click', () => {
                        this.toggleTheme();
                    });
                }

                const langSwitch = DOM.get('langSwitch');
                if (langSwitch) {
                    memoryManager.addEventListener(langSwitch, 'click', () => {
                        const nextLang = languageManager.getNextLanguage();
                        languageManager.switchLanguage(nextLang);
                    });
                }
            }

            setupImageHandling() {
                const imageInput = DOM.get('imageInput');
                if (imageInput) {
                    memoryManager.addEventListener(imageInput, 'change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            await imageManager.initializeCropModal(file);
                            e.target.value = '';
                        }
                    });
                }
            }

            setupDownloadHandling() {
                memoryManager.addEventListener(document, 'keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 's') {
                            e.preventDefault();
                            exportManager.exportHighQuality();
                        }
                    }
                });
            }

            toggleTheme() {
                try {
                    const isDarkMode = document.body.classList.contains('night-mode');
                    const sunIcon = document.querySelector('.sun-icon');
                    const moonIcon = document.querySelector('.moon-icon');
                    
                    if (isDarkMode) {
                        document.body.classList.remove('night-mode');
                        if (sunIcon) sunIcon.style.display = 'block';
                        if (moonIcon) moonIcon.style.display = 'none';
                        accessibilityManager.announce('Light mode activated');
                    } else {
                        document.body.classList.add('night-mode');
                        if (sunIcon) sunIcon.style.display = 'none';
                        if (moonIcon) moonIcon.style.display = 'block';
                        accessibilityManager.announce('Dark mode activated');
                    }
                    
                    performanceMonitor.scheduleDraw();
                } catch (error) {
                    memoryManager.logError('THEME_TOGGLE_ERROR', error);
                }
            }
        }

        // Initialize event listeners manager
        const eventListenersManager = new EventListenersManager();

        // ✅ FIXED: Enhanced App Initialization
        class AppInitializer {
            constructor() {
                this.initializationSteps = [
                    { name: 'DOM Validation', fn: () => DOM.validateCriticalElements() },
                    { name: 'Service Worker', fn: () => ServiceWorkerManager.register() },
                    { name: 'Font Preloading', fn: () => fontManager.preloadFonts() },
                    { name: 'Canvas Setup', fn: () => this.setupInitialCanvas() },
                    { name: 'UI Initialization', fn: () => this.initializeUI() },
                    { name: 'Cleanup Setup', fn: () => this.setupCleanupHandlers() }
                ];
            }

            async initialize() {
                try {
                    let completedSteps = 0;
                    
                    for (const step of this.initializationSteps) {
                        try {
                            console.log(`🔄 ${step.name}...`);
                            await step.fn();
                            completedSteps++;
                            console.log(`✅ ${step.name} completed`);
                        } catch (error) {
                            console.warn(`⚠️ ${step.name} failed:`, error);
                            memoryManager.logError(`${step.name.toUpperCase()}_ERROR`, error);
                        }
                    }
                    
                    // Finalize initialization
                    await this.finalizeInit();
                    
                    console.log(`🎉 DACO Storymaker Pro initialized successfully! (${completedSteps}/${this.initializationSteps.length} steps completed)`);
                    return true;
                } catch (error) {
                    console.error('❌ Critical initialization error:', error);
                    memoryManager.logError('INIT_CRITICAL_ERROR', error);
                    return false;
                }
            }

            setupInitialCanvas() {
                try {
                    const canvas = DOM.get('canvas');
                    if (!canvas) {
                        throw new Error('Canvas element not found');
                    }
                    
                    // Set initial canvas size
                    const targetRatio = 9/16;
                    const container = document.querySelector('.canvas-container');
                    if (!container) {
                        throw new Error('Canvas container not found');
                    }
                    
                    const containerRect = container.getBoundingClientRect();
                    let canvasWidth, canvasHeight;
                    
                    if (targetRatio > containerRect.width / containerRect.height) {
                        canvasWidth = Math.min(containerRect.width * 0.75, 350);
                        canvasHeight = canvasWidth / targetRatio;
                    } else {
                        canvasHeight = Math.min(containerRect.height * 0.75, 500);
                        canvasWidth = canvasHeight * targetRatio;
                    }
                    
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    
                    // Initial draw
                    canvasRenderer.drawCanvas();
                    
                    return true;
                } catch (error) {
                    memoryManager.logError('CANVAS_SETUP_ERROR', error);
                    return false;
                }
            }

            initializeUI() {
                try {
                    // Initialize color grids
                    const textColorGrid = DOM.get('textColorGrid');
                    const bgColorGrid = DOM.get('bgColorGrid');
                    
                    if (textColorGrid) {
                        uiManager.createColorGrid(textColorGrid, (color) => {
                            if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                                appState.textObjects[appState.selectedTextIndex].color = color;
                                performanceMonitor.scheduleDraw();
                            }
                        });
                    }
                    
                    if (bgColorGrid) {
                        uiManager.createColorGrid(bgColorGrid, (color) => {
                            if (appState.selectedTextIndex >= 0 && appState.textObjects[appState.selectedTextIndex]) {
                                appState.textObjects[appState.selectedTextIndex].backdropColor = color;
                                performanceMonitor.scheduleDraw();
                            }
                        });
                    }
                    
                    // Initialize slider values
                    uiManager.updateSliderValues();
                    
                    // Set initial theme based on user preference
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        document.body.classList.add('night-mode');
                        const sunIcon = document.querySelector('.sun-icon');
                        const moonIcon = document.querySelector('.moon-icon');
                        if (sunIcon) sunIcon.style.display = 'none';
                        if (moonIcon) moonIcon.style.display = 'block';
                    }
                    
                    // Listen for theme changes
                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                        if (event.matches) {
                            document.body.classList.add('night-mode');
                            const sunIcon = document.querySelector('.sun-icon');
                            const moonIcon = document.querySelector('.moon-icon');
                            if (sunIcon) sunIcon.style.display = 'none';
                            if (moonIcon) moonIcon.style.display = 'block';
                        } else {
                            document.body.classList.remove('night-mode');
                            const sunIcon = document.querySelector('.sun-icon');
                            const moonIcon = document.querySelector('.moon-icon');
                            if (sunIcon) sunIcon.style.display = 'block';
                            if (moonIcon) moonIcon.style.display = 'none';
                        }
                        performanceMonitor.scheduleDraw();
                    });
                    
                    return true;
                } catch (error) {
                    memoryManager.logError('UI_INIT_ERROR', error);
                    return false;
                }
            }

            setupCleanupHandlers() {
                try {
                    // Page unload cleanup
                    memoryManager.addEventListener(window, 'beforeunload', () => {
                        memoryManager.cleanup();
                        appState.cleanup();
                    });
                    
                    // Visibility change cleanup
                    memoryManager.addEventListener(document, 'visibilitychange', () => {
                        if (document.hidden) {
                            performanceMonitor.reset();
                        }
                    });
                    
                    // Resize handler
                    let resizeTimeout;
                    memoryManager.addEventListener(window, 'resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            canvasRenderer.updateCanvasBounds();
                            performanceMonitor.scheduleDraw(true);
                        }, 100);
                    });
                    
                    return true;
                } catch (error) {
                    memoryManager.logError('CLEANUP_SETUP_ERROR', error);
                    return false;
                }
            }

            async finalizeInit() {
                try {
                    // Hide loading screen
                    const loadingScreen = DOM.get('dacoLoadingScreen');
                    if (loadingScreen) {
                        await new Promise(resolve => {
                            setTimeout(() => {
                                loadingScreen.classList.add('hidden');
                                setTimeout(() => {
                                    loadingScreen.style.display = 'none';
                                    resolve();
                                }, 800);
                            }, 1000);
                        });
                    }
                    
                    // Final performance check
                    console.log('📊 Performance Report:', performanceMonitor.getPerformanceReport());
                    console.log('💾 Memory Usage:', memoryManager.getMemoryUsage());
                    
                    // Announce app ready
                    accessibilityManager.announce('DACO Storymaker Pro is ready to use');
                    
                    return true;
                } catch (error) {
                    memoryManager.logError('FINALIZE_ERROR', error);
                    return false;
                }
            }
        }

        // ✅ FIXED: Enhanced App Launch
        async function launchApp() {
            try {
                console.log('🚀 Starting DACO Storymaker Pro v5.2.0...');
                
                const appInitializer = new AppInitializer();
                const initSuccess = await appInitializer.initialize();
                
                if (initSuccess) {
                    console.log('🎊 DACO Storymaker Pro launched successfully!');
                    console.log('🏆 Zero-Bug Edition - All systems operational');
                } else {
                    console.warn('⚠️ App launched with some limitations');
                }
                
            } catch (error) {
                console.error('💥 Critical launch error:', error);
                errorBoundary.handleError(error);
                
                // Fallback initialization
                const loadingScreen = DOM.get('dacoLoadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
                
                showAlert('App initialization encountered issues, but basic functionality is available.');
            }
        }

        // ✅ Launch the application
        if (document.readyState === 'loading') {
            memoryManager.addEventListener(document, 'DOMContentLoaded', launchApp);
        } else {
            launchApp();
        }

    </script>
</body>
</html>
